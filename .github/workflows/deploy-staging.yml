name: Deploy to Staging

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      commit_sha:
        description: 'Commit SHA to deploy (leave empty for latest)'
        required: false
        type: string

concurrency:
  group: deploy-staging
  cancel-in-progress: false

jobs:
  # Build the application
  build:
    name: Build Application
    runs-on: ubuntu-latest
    outputs:
      deployment-id: ${{ steps.deployment.outputs.deployment-id }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.commit_sha || github.sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
          NEXT_PUBLIC_APP_URL: ${{ secrets.STAGING_APP_URL }}

      - name: Generate version info
        id: version
        run: |
          VERSION="${{ github.sha }}-$(date +%s)"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "$VERSION" > version.txt

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: staging-build-${{ steps.version.outputs.version }}
          path: |
            .next/
            public/
            package.json
            package-lock.json
            prisma/
            version.txt
          retention-days: 7

      - name: Create deployment
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'staging',
              required_contexts: [],
              auto_merge: false,
              description: 'Staging deployment from CI'
            });
            core.setOutput('deployment-id', deployment.data.id);
            return deployment.data.id;

  # Run database migrations
  migrate:
    name: Database Migration
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: staging
      url: ${{ secrets.STAGING_APP_URL }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Check migration status
        run: npx prisma migrate status
        env:
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}

      - name: Run database migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Verify database connection
        run: |
          node -e "
          const { PrismaClient } = require('@prisma/client');
          const prisma = new PrismaClient();
          prisma.\$connect()
            .then(() => { console.log('✅ Database connection successful'); process.exit(0); })
            .catch((e) => { console.error('❌ Database connection failed:', e); process.exit(1); });
          "
        env:
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}

  # Deploy to Vercel
  deploy:
    name: Deploy to Vercel
    runs-on: ubuntu-latest
    needs: [build, migrate]
    environment:
      name: staging
      url: ${{ secrets.STAGING_APP_URL }}
    outputs:
      deployment-url: ${{ steps.deploy.outputs.deployment-url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: staging-build-${{ needs.build.outputs.version }}

      - name: Deploy to Vercel
        id: deploy
        run: |
          npm install -g vercel
          DEPLOYMENT_URL=$(vercel deploy --token=${{ secrets.VERCEL_TOKEN }} \
            --env ENVIRONMENT=staging \
            --env DATABASE_URL="${{ secrets.STAGING_DATABASE_URL }}" \
            --env NEXT_PUBLIC_APP_URL="${{ secrets.STAGING_APP_URL }}" \
            --env CLERK_SECRET_KEY="${{ secrets.STAGING_CLERK_SECRET_KEY }}" \
            --env RESEND_API_KEY="${{ secrets.RESEND_API_KEY }}" \
            --build-env DATABASE_URL="${{ secrets.STAGING_DATABASE_URL }}" \
            --yes)
          echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "Deployed to: $DEPLOYMENT_URL"

      - name: Alias to staging domain
        run: |
          vercel alias set ${{ steps.deploy.outputs.deployment-url }} staging-lazygamedevs.vercel.app \
            --token=${{ secrets.VERCEL_TOKEN }} \
            --scope=${{ secrets.VERCEL_ORG_ID }}

  # Health checks
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Wait for deployment to be ready
        run: sleep 30

      - name: Check health endpoint
        id: health
        run: |
          MAX_ATTEMPTS=10
          ATTEMPT=0
          DELAY=10

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            echo "Health check attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS"

            STATUS=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.STAGING_APP_URL }}/api/health || echo "000")

            if [ "$STATUS" = "200" ]; then
              echo "✅ Health check passed!"
              exit 0
            fi

            echo "❌ Health check failed with status: $STATUS"
            ATTEMPT=$((ATTEMPT + 1))

            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              echo "Waiting ${DELAY}s before retry..."
              sleep $DELAY
            fi
          done

          echo "❌ Health check failed after $MAX_ATTEMPTS attempts"
          exit 1

      - name: Check database connectivity
        run: |
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.STAGING_APP_URL }}/api/health/db || echo "000")

          if [ "$STATUS" = "200" ]; then
            echo "✅ Database connectivity check passed!"
            exit 0
          else
            echo "❌ Database connectivity check failed with status: $STATUS"
            exit 1
          fi

      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."

          # Test homepage
          curl -f ${{ secrets.STAGING_APP_URL }} || exit 1

          # Test API health
          curl -f ${{ secrets.STAGING_APP_URL }}/api/health || exit 1

          echo "✅ Smoke tests passed!"

  # Update deployment status
  update-deployment:
    name: Update Deployment Status
    runs-on: ubuntu-latest
    needs: [build, deploy, health-check]
    if: always()
    steps:
      - name: Update deployment status - Success
        if: needs.health-check.result == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ needs.build.outputs.deployment-id }},
              state: 'success',
              environment_url: '${{ secrets.STAGING_APP_URL }}',
              description: 'Deployment successful and health checks passed',
              auto_inactive: true
            });

      - name: Update deployment status - Failure
        if: needs.health-check.result != 'success'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ needs.build.outputs.deployment-id }},
              state: 'failure',
              description: 'Deployment failed or health checks did not pass'
            });

  # Send notifications
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [build, deploy, health-check]
    if: always()
    steps:
      - name: Notify Slack - Success
        if: needs.health-check.result == 'success'
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "✅ Staging Deployment Successful",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Staging Deployment Successful* ✅\n\n*Repository:* ${{ github.repository }}\n*Branch:* ${{ github.ref_name }}\n*Commit:* <${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>\n*Author:* ${{ github.actor }}\n*Version:* ${{ needs.build.outputs.version }}\n*URL:* ${{ secrets.STAGING_APP_URL }}\n*Workflow:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      - name: Notify Slack - Failure
        if: needs.health-check.result != 'success'
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "❌ Staging Deployment Failed",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Staging Deployment Failed* ❌\n\n*Repository:* ${{ github.repository }}\n*Branch:* ${{ github.ref_name }}\n*Commit:* <${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>\n*Author:* ${{ github.actor }}\n*Workflow:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>\n\n@here Please investigate the failure."
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      - name: Notify Discord
        if: always()
        run: |
          if [ "${{ needs.health-check.result }}" = "success" ]; then
            STATUS="✅ Success"
            COLOR="3066993"
          else
            STATUS="❌ Failed"
            COLOR="15158332"
          fi

          curl -X POST ${{ secrets.DISCORD_WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"Staging Deployment $STATUS\",
                \"description\": \"Repository: ${{ github.repository }}\\nBranch: ${{ github.ref_name }}\\nCommit: ${{ github.sha }}\\nAuthor: ${{ github.actor }}\",
                \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
                \"color\": $COLOR,
                \"fields\": [
                  {\"name\": \"Environment\", \"value\": \"Staging\", \"inline\": true},
                  {\"name\": \"Version\", \"value\": \"${{ needs.build.outputs.version }}\", \"inline\": true},
                  {\"name\": \"URL\", \"value\": \"${{ secrets.STAGING_APP_URL }}\", \"inline\": false}
                ]
              }]
            }" || echo "Discord notification failed"

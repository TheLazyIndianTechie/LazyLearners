{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Complete Database Seeding and Sample Content Generation",
        "description": "Populate the database with comprehensive sample data including courses, users, lessons, and test content to enable full platform functionality testing",
        "details": "Create Prisma seed script (prisma/seed.ts) with realistic sample data: 1) Generate 50+ sample courses across Unity, Unreal, and Godot with proper categories and difficulty levels 2) Create test user accounts for all roles (students, instructors, admins) with proper OAuth integration 3) Add sample course modules and lessons with placeholder video content 4) Generate mock payment records and license keys for testing enrollment flows 5) Include forum posts, reviews, and user progress data 6) Ensure all database relationships are properly populated with referential integrity",
        "testStrategy": "Run seed script and verify: database contains sample courses accessible via API, user authentication works with seeded accounts, course enrollment flows function with sample license keys, all relationships properly established without foreign key errors",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Enhance existing seed script with comprehensive course data generation",
            "description": "Expand the current prisma/seed.ts to generate 50+ courses across all categories (Unity, Unreal, Godot) with proper distribution, realistic metadata, and comprehensive content structure",
            "dependencies": [],
            "details": "Modify the existing seed.ts file to create 50+ courses instead of the current 5. Use the existing course structure as a template but expand it to cover all categories (GAME_PROGRAMMING, GAME_DESIGN, GAME_ART, GAME_AUDIO, UNITY_DEVELOPMENT, UNREAL_DEVELOPMENT, GODOT_DEVELOPMENT, MOBILE_GAMES, INDIE_DEVELOPMENT, VR_AR_DEVELOPMENT). Each course should have realistic titles, descriptions, pricing ($29.99-$199.99), proper difficulty distribution (30% BEGINNER, 50% INTERMEDIATE, 20% ADVANCED), and varied course durations (1200-4800 minutes). Include course requirements, objectives, and tags for each course.",
            "status": "done",
            "testStrategy": "Run seed script and verify database contains 50+ courses with proper category distribution, all difficulty levels represented, realistic pricing ranges, and complete metadata including requirements, objectives, and tags",
            "updatedAt": "2025-10-02T11:45:23.864Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Generate comprehensive user accounts with OAuth integration support",
            "description": "Create diverse test user accounts for all roles (students, instructors, admins) with realistic profiles, skills, and OAuth provider compatibility",
            "dependencies": [],
            "details": "Expand user creation in seed.ts to generate 20+ students, 10+ instructors, and 3 admin users. Include realistic names, emails, bios, locations, and skills for each user. Create Account records for OAuth providers (Google, GitHub) for testing authentication flows. Ensure each instructor has expertise in specific game engines and categories. Students should have varied skill levels and interests. Include profile images, websites, and portfolio data where appropriate.",
            "status": "done",
            "testStrategy": "Verify seeded users can authenticate via both credentials and OAuth providers, instructor profiles display relevant expertise, student profiles show appropriate skill levels, and all role-based permissions function correctly",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T13:50:54.537Z"
          },
          {
            "id": 3,
            "title": "Create extensive course modules and lessons with placeholder video content",
            "description": "Generate realistic course module structures with 3-8 modules per course, each containing 4-12 lessons with proper lesson types and placeholder video content",
            "dependencies": [],
            "details": "For each of the 50+ courses, create a realistic module structure. Each course should have 3-8 modules with logical progression (Introduction, Fundamentals, Intermediate Concepts, Advanced Topics, Projects, Publishing). Each module should contain 4-12 lessons with varied types (VIDEO, INTERACTIVE, QUIZ, PROJECT, READING). Include realistic lesson titles, descriptions, durations (15-90 minutes), and placeholder video URLs. Add lesson resources, quiz data, and proper content JSON structures. Ensure total course duration matches the calculated sum of lesson durations.",
            "status": "done",
            "testStrategy": "Verify courses display proper module hierarchy, lessons load with correct metadata, video placeholder URLs are accessible, quiz data is properly structured, and course duration calculations are accurate",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T13:54:24.485Z"
          },
          {
            "id": 4,
            "title": "Generate mock payment records and license key system data",
            "description": "Create comprehensive payment history with successful transactions, license key generation, and enrollment flows for testing the complete purchase-to-access pipeline",
            "dependencies": [],
            "details": "Generate 100+ payment records using Dodo Payment format with varied statuses (SUCCEEDED, FAILED, PENDING). Create corresponding license keys for successful payments with proper key formats (ENGINE-COURSE-YEAR-HASH), activation limits (1-5), and expiration dates. Include payment metadata with realistic payment methods (card, paypal), amounts matching course prices, and proper timestamps. Ensure license keys properly link to payments and enable course access. Create failed payment scenarios for testing error handling.",
            "status": "done",
            "testStrategy": "Verify payment records display correct transaction details, license keys grant course access, enrollment flows work end-to-end, payment failures are handled gracefully, and webhook simulation works with seeded data",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T14:42:12.353Z"
          },
          {
            "id": 5,
            "title": "Populate community features with forum posts, reviews, and user progress data",
            "description": "Generate engaging forum discussions, course reviews, user progress tracking, portfolios, and certification data to create a vibrant learning community environment",
            "dependencies": [],
            "details": "Create 50+ forum posts across categories (Unity, Unreal, Godot, General, Help) with realistic titles, content, and threaded replies. Generate course reviews (3-5 star ratings) with detailed comments for each course. Create user progress records showing various completion states (0-100%) across enrolled courses. Build student portfolios with 2-4 showcase projects each, including game screenshots, descriptions, and links. Generate certifications for completed courses and add user achievements. Include forum post likes, views, and engagement metrics.",
            "status": "done",
            "testStrategy": "Verify forum displays active discussions with proper threading, course pages show realistic review distributions, student dashboards display accurate progress tracking, portfolios showcase projects correctly, and certification verification works properly",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T19:05:01.153Z"
          },
          {
            "id": 6,
            "title": "Expand payment record generation with comprehensive payment scenarios",
            "description": "Enhance the existing seed script to generate 100+ diverse payment records covering all payment statuses (SUCCEEDED, FAILED, PENDING, CANCELLED, PROCESSING, REQUIRES_PAYMENT_METHOD), multiple payment methods (card, paypal, bank_transfer), and realistic metadata patterns matching Dodo Payments format",
            "dependencies": [],
            "details": "Modify the existing payment generation section in prisma/seed.ts (around lines 2084-2140) to create comprehensive payment scenarios: 70% SUCCEEDED payments, 15% FAILED, 10% PENDING, 3% CANCELLED, 2% PROCESSING. Include realistic Dodo payment IDs, varied amounts matching course prices, different payment methods with metadata (card types, last4 digits, transaction fees), timestamps spread across the last 6 months, and proper currency handling for international users.",
            "status": "done",
            "testStrategy": "Verify payment records span all statuses, amounts match course prices, metadata follows Dodo format, and foreign key relationships are maintained",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T19:05:19.961Z"
          },
          {
            "id": 7,
            "title": "Generate comprehensive license key system with proper key formats and activation tracking",
            "description": "Create extensive license key records following the ENGINE-COURSE-YEAR-HASH format, with proper activation limits, expiration dates, and status management covering all license key statuses and realistic usage patterns",
            "dependencies": [
              "1.6"
            ],
            "details": "Expand license key generation to create keys for all successful payments with format like 'UNITY-COURSE-2024-ABC123', 'UNREAL-ADV-2024-XYZ789'. Set varied activation limits (1-5), track realistic activation counts, implement proper expiration dates (6 months to 2 years), and include different statuses (80% ACTIVE, 15% EXPIRED, 4% DISABLED, 1% REVOKED). Ensure all successful payments have corresponding license keys that enable course access.",
            "status": "done",
            "testStrategy": "Confirm all successful payments have license keys, key formats are consistent, activation tracking works correctly, and expiration logic is properly implemented",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T19:05:19.964Z"
          },
          {
            "id": 8,
            "title": "Create failed payment scenarios with realistic failure patterns and retry mechanisms",
            "description": "Generate failed payment records with realistic failure reasons, metadata indicating why payments failed, and simulate retry patterns that match real-world payment processing scenarios",
            "dependencies": [
              "1.6"
            ],
            "details": "Create failed payment scenarios including insufficient funds, expired cards, declined transactions, network timeouts, and fraud detection triggers. Add failure metadata with error codes, bank responses, and retry attempts. Include both immediate failures and payments that failed after initial success. Ensure failed payments don't generate license keys and maintain proper audit trails for debugging payment flows.",
            "status": "done",
            "testStrategy": "Verify failed payments have no license keys, failure metadata is realistic, retry patterns are logical, and audit trails are complete",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T19:05:19.965Z"
          },
          {
            "id": 9,
            "title": "Implement enrollment flow simulation linking payments to course access",
            "description": "Create the complete purchase-to-access pipeline by linking payment records to course enrollments, ensuring successful payments enable course access while failed payments block access, with proper enrollment status tracking",
            "dependencies": [
              "1.6",
              "1.7"
            ],
            "details": "Connect payment success to automatic enrollment creation with ACTIVE status, link license key activation to enrollment permissions, implement enrollment blocking for failed/cancelled payments, and create enrollment history tracking. Include scenarios where users purchase multiple courses, have mixed payment statuses, and simulate the complete user journey from payment to course access. Ensure the enrollment table properly reflects payment status and license key validity.",
            "status": "done",
            "testStrategy": "Test complete user journeys: successful payment creates enrollment and grants access, failed payment blocks enrollment, license key validation enables video streaming, and enrollment status reflects payment state",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T19:05:19.966Z"
          },
          {
            "id": 10,
            "title": "Add payment analytics data and comprehensive reporting scenarios",
            "description": "Generate payment analytics data including refunds, partial payments, subscription renewals, and bulk purchase scenarios to enable comprehensive testing of payment reporting and financial tracking features",
            "dependencies": [
              "1.6",
              "1.7",
              "1.8",
              "1.9"
            ],
            "details": "Create advanced payment scenarios including refund records with original payment references, partial payment handling for payment plans, subscription-based payments with renewal tracking, bulk course purchases with group discounts, international payments with currency conversion data, and chargeback scenarios. Include comprehensive metadata for analytics: payment processor fees, tax calculations, discount applications, affiliate commissions, and financial reporting data needed for dashboard metrics.",
            "status": "done",
            "testStrategy": "Verify refund tracking works correctly, subscription renewals are handled properly, bulk purchases apply discounts correctly, analytics data enables reporting dashboards, and financial calculations are accurate",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T19:05:19.967Z"
          }
        ],
        "updatedAt": "2025-10-02T19:05:19.967Z"
      },
      {
        "id": 2,
        "title": "Implement Comprehensive Course Management Interface for Instructors",
        "description": "Build complete course creation and management UI enabling instructors to create, edit, and publish courses with modules and lessons",
        "details": "Create instructor course management system: 1) Course creation form with title, description, category, difficulty, pricing using shadcn/ui components 2) Module and lesson management with drag-and-drop reordering using @dnd-kit 3) Rich text editor for course descriptions and lesson content 4) Video upload interface with progress tracking and thumbnail generation 5) Course preview functionality for content validation 6) Publishing workflow with course status management (draft/published/archived) 7) Course analytics dashboard showing enrollment and completion metrics 8) Integration with existing payment system for course pricing",
        "testStrategy": "Test instructor workflow: create course from scratch, add multiple modules and lessons, upload video content, preview course as student, publish course and verify it appears in marketplace, check analytics dashboard displays correct data",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate @dnd-kit for module and lesson drag-and-drop reordering",
            "description": "Implement drag-and-drop functionality for reordering modules and lessons within the course content tab using @dnd-kit library which is already installed in the project",
            "dependencies": [],
            "details": "Import DndContext, closestCenter, SortableContext, sortableKeyboardCoordinates, useSortable from @dnd-kit libraries. Wrap the modules list in course edit page with DndContext and SortableContext. Create a SortableModule component for each module that can be dragged and dropped. Add drag handle (GripVertical icon) and implement onDragEnd handler to update module order in the database via API call to /api/courses/[id]/modules/[moduleId] with new order. Similarly implement lesson reordering within modules.",
            "status": "done",
            "testStrategy": "Test drag-and-drop functionality for modules and lessons, verify order persistence in database, test keyboard navigation for accessibility",
            "updatedAt": "2025-10-04T04:58:51.657Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrate VideoUploadZone component into course editor",
            "description": "Add the existing VideoUploadZone component to lesson editing pages and enhance the course content management workflow with video upload capabilities",
            "dependencies": [],
            "details": "Import VideoUploadZone from src/components/video/video-upload-zone.tsx into the course edit page and lesson edit pages. Add video upload functionality to the lesson creation/editing workflow. Integrate with the existing lesson video field in the database. Add a video tab in lesson editing that uses VideoUploadZone with courseId and lessonId metadata. Handle upload completion to automatically update lesson videoUrl field and duration based on video metadata.",
            "status": "done",
            "testStrategy": "Test video upload workflow, verify video metadata extraction, test progress tracking and error handling during upload",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T04:59:06.806Z"
          },
          {
            "id": 3,
            "title": "Enhance rich text editor with advanced features",
            "description": "Extend the existing RichTextEditor component with additional features like image/video embedding, code syntax highlighting, and link insertion",
            "dependencies": [],
            "details": "Extend the existing rich-text-editor.tsx by adding @tiptap/extension-link, @tiptap/extension-image, and @tiptap/extension-code-block-lowlight extensions. Add toolbar buttons for inserting links, images, and embedded videos. Implement image upload functionality that integrates with the video upload system. Add syntax highlighting for code blocks using lowlight. Create modal dialogs for link insertion and image/video embedding with proper URL validation.",
            "status": "done",
            "testStrategy": "Test all new editor features, verify image/video embedding, test code syntax highlighting, validate link insertion and URL validation",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T04:59:29.703Z"
          },
          {
            "id": 4,
            "title": "Implement course preview functionality",
            "description": "Create a comprehensive course preview system that shows instructors how their course appears to students before publishing",
            "dependencies": [
              "2.2"
            ],
            "details": "Create a new preview mode in the course edit page that renders the course exactly as students will see it. Add a Preview tab or modal that displays course details, modules, lessons, and video content in student view. Implement preview navigation between lessons and modules. Add preview controls for instructors to test video playback, lesson progression, and content formatting. Include preview access to quiz functionality if lessons contain quizzes.",
            "status": "done",
            "testStrategy": "Test preview accuracy compared to actual student view, verify all course content displays correctly, test video playback and navigation in preview mode",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T05:01:01.941Z"
          },
          {
            "id": 5,
            "title": "Build publishing workflow with validation checklist",
            "description": "Create a comprehensive course publishing system with validation requirements and status management",
            "dependencies": [
              "2.3"
            ],
            "details": "Create a publishing workflow component that validates course readiness before allowing publication. Implement validation checklist: course has title/description, at least one module, modules have lessons, video lessons have uploaded videos, pricing is set. Create course status management (draft/review/published/archived) with appropriate UI indicators. Add publishing confirmation dialog with final checklist review. Implement auto-save for draft courses and version control for published course updates.",
            "status": "done",
            "testStrategy": "Test validation logic for all required fields, verify status transitions, test publishing workflow and confirmation process",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create course settings panel for advanced configuration",
            "description": "Build a comprehensive settings panel for course pricing, access control, drip content scheduling, and enrollment management",
            "dependencies": [],
            "details": "Extend the existing Settings tab in course edit page with advanced options. Add pricing configuration with discount options and bulk pricing. Implement access control settings (free/paid/subscription). Create drip content scheduling interface for releasing lessons over time. Add enrollment limits and enrollment period settings. Include course visibility settings (public/private/unlisted) and prerequisite course selection.",
            "status": "done",
            "testStrategy": "Test all pricing configurations, verify access control functionality, test drip content scheduling logic, validate enrollment management features",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T05:00:30.910Z"
          },
          {
            "id": 7,
            "title": "Add module and lesson duplication and templates features",
            "description": "Implement functionality to duplicate existing modules/lessons and create reusable templates for course creation efficiency",
            "dependencies": [
              "2.1"
            ],
            "details": "Add duplicate buttons to module and lesson components that create copies with 'Copy of' prefix. Implement template system where instructors can save modules/lessons as templates for reuse across courses. Create template library interface accessible from course creation. Add template categories (introduction, project-based, quiz, etc.). Implement template sharing between instructors with permission controls. Include template preview and customization before applying to courses.",
            "status": "done",
            "testStrategy": "Test duplication functionality for modules and lessons, verify template creation and application, test template sharing and permission controls",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement auto-save functionality for draft courses",
            "description": "Add automatic saving of course changes to prevent data loss and improve user experience during course creation and editing",
            "dependencies": [
              "2.5"
            ],
            "details": "Implement auto-save functionality using debounced API calls when course data changes. Add visual indicators for save status (saving/saved/error). Create auto-save for all course fields including title, description, modules, lessons, and settings. Implement conflict resolution for concurrent edits. Add manual save button and keyboard shortcuts (Ctrl+S). Store auto-save timestamps and provide recovery options for unsaved changes. Include auto-save preferences in user settings.",
            "status": "done",
            "testStrategy": "Test auto-save timing and debouncing, verify save status indicators, test conflict resolution and recovery functionality, validate keyboard shortcuts",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-04T05:53:07.577Z"
      },
      {
        "id": 3,
        "title": "Integrate Video Streaming with Course Lesson Content",
        "description": "Connect the existing video streaming infrastructure with course lessons to enable seamless video playback within the learning experience",
        "details": "Implement video-lesson integration: 1) Extend lesson model to include video metadata (duration, quality options, thumbnails) 2) Create lesson video player component with progress tracking and resume functionality 3) Implement video access control using license key validation from existing system 4) Add video quality selection and adaptive streaming integration 5) Create video progress tracking that updates user completion status 6) Implement video bookmarking and note-taking features 7) Add video analytics for engagement metrics 8) Ensure mobile-responsive video playback with touch controls",
        "testStrategy": "Verify video integration: enrolled students can watch lesson videos, progress is tracked and resumable, video quality adapts to connection, unauthorized users cannot access content, mobile video playback functions properly",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend Prisma schema with video metadata and progress models",
            "description": "Add video-specific fields to Lesson model and create new VideoProgress and VideoBookmark models for comprehensive video tracking",
            "details": "Modify prisma/schema.prisma to add: 1) Lesson model extensions - videoMetadata (JSON: qualities, bitrate, resolution, frameRate), videoThumbnails (String array), videoDuration (Int seconds). 2) Create VideoProgress model - fields: id, userId, lessonId, watchTime (Int), completionPercentage (Float), lastPosition (Int), resumePosition (Int), qualityPreference (String), playbackSpeed (Float), timestamps. 3) Create VideoBookmark model - id, userId, lessonId, position (Int), note (String), createdAt. Add indexes and relations. Run prisma generate and prisma db push.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create lesson video streaming API routes",
            "description": "Build API endpoints for lesson video operations including streaming initialization, progress updates, and session management",
            "details": "Create src/app/api/lessons/[lessonId]/video/route.ts - GET endpoint to initialize video streaming session with enrollment and license validation. Create src/app/api/lessons/[lessonId]/progress/route.ts - POST to save progress, GET to retrieve. Create src/app/api/lessons/[lessonId]/bookmarks/route.ts - CRUD operations for video bookmarks. Add Zod validation schemas in src/lib/validations/video.ts for request/response validation. Return SecureStreamingManifest with lesson context.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate enrollment and license validation into video access control",
            "description": "Extend VideoStreamingService.verifyVideoAccess to check user enrollment status and license key validity before allowing lesson video access",
            "details": "Modify src/lib/video/streaming.ts - Update verifyVideoAccess method to: 1) Query Prisma for user enrollment via Enrollment model. 2) Validate active LicenseKey for the course. 3) Check lesson ownership via Course → Module → Lesson relationship. 4) Return appropriate VideoAccess with restrictions based on enrollment type (free preview vs full access). 5) Log security events for unauthorized access attempts. Add helper methods: checkEnrollment(userId, courseId), validateLicense(userId, courseId), getLessonCourse(lessonId).",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3,
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build LessonVideoPlayer component with progress tracking",
            "description": "Create a lesson-aware video player component that wraps the existing VideoPlayer with automatic progress saving and resume functionality",
            "details": "Create src/components/video/lesson-video-player.tsx - Component that: 1) Accepts lessonId, courseId props. 2) Fetches lesson video metadata and user progress on mount. 3) Wraps VideoPlayer with onProgress callback that saves position to localStorage every 10s and database every 30s. 4) Implements resume logic - loads lastPosition from database, offers resume UI if position > 30s. 5) Tracks completion - calls /api/lessons/[id]/progress when 90% watched. 6) Integrates bookmark UI. 7) Handles loading states and error boundaries. Use React Query for data fetching and mutations.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3,
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement video progress synchronization system",
            "description": "Create a robust progress sync mechanism using localStorage for immediate updates and database for persistence with conflict resolution",
            "details": "Create src/lib/video/progress-sync.ts - Service with: 1) saveProgressLocal(lessonId, position, watchTime) - localStorage save. 2) saveProgressRemote(lessonId, data) - API call with debouncing (30s). 3) loadProgress(lessonId) - Load from DB, fallback to localStorage. 4) syncOnVisibilityChange - Sync when tab becomes hidden. 5) conflictResolution - Use max(local.position, remote.position) strategy. 6) useVideoProgress hook for React components. Add background sync using Service Worker API for offline support. Handle edge cases: multiple tabs, network failures, stale data.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3,
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement lesson completion logic based on video watch percentage",
            "description": "Create automatic lesson completion system that marks lessons complete at 90% video watch threshold and updates course progress",
            "details": "Create src/lib/video/completion.ts - Functions: 1) calculateCompletionPercentage(watchTime, videoDuration). 2) shouldMarkComplete(percentage) - returns true if >= 90%. 3) markLessonComplete(userId, lessonId) - Update Progress model with completed: true, completedAt timestamp. 4) updateCourseProgress(userId, courseId) - Recalculate overall course completion based on all lesson statuses. 5) triggerCompletionEvents - Send notifications, unlock next lesson, award points. Modify /api/lessons/[id]/progress POST endpoint to call these functions. Add database transaction to ensure atomicity. Create completion webhooks for integrations.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3,
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Create video bookmarking and note-taking system",
            "description": "Build a feature allowing students to bookmark video timestamps with notes for future reference and review",
            "details": "1) Database: VideoBookmark model (already defined in subtask 3.1). 2) API: src/app/api/lessons/[lessonId]/bookmarks/route.ts - GET list, POST create, PATCH update, DELETE remove. Add GET /api/users/[userId]/bookmarks for all user bookmarks. 3) UI Component: src/components/video/video-bookmarks.tsx - Bookmark list sidebar, add bookmark button on video player timeline, edit/delete actions, timestamp click to seek video. 4) Integration: Add bookmark controls to LessonVideoPlayer, sync bookmark positions with video timeline, export bookmarks as PDF/Markdown. Use optimistic UI updates with React Query mutations.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3,
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Build instructor video analytics dashboard",
            "description": "Create analytics aggregation system and dashboard for instructors to view student engagement with lesson videos",
            "details": "1) Analytics Service: src/lib/video/analytics.ts - aggregateVideoMetrics(lessonId, timeRange) - total views, unique viewers, avg watch time, completion rate, drop-off points. 2) API: src/app/api/instructor/lessons/[lessonId]/analytics/route.ts - GET endpoint returning analytics data. 3) Dashboard UI: src/app/instructor/courses/[courseId]/analytics/page.tsx - Charts for watch time distribution, completion funnel, engagement heatmap (which parts watched most), quality selection stats, device breakdown. Use recharts for visualizations. 4) Cache analytics data in Redis with 1-hour TTL. 5) Export analytics as CSV/PDF reports.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3,
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Add adaptive quality selection and bandwidth optimization",
            "description": "Integrate existing adaptive streaming infrastructure with lesson videos for automatic quality switching based on network conditions",
            "details": "1) Extend src/lib/video/streaming.ts - Add getOptimalQuality(bandwidth, deviceCapabilities) method. 2) Modify LessonVideoPlayer to monitor buffer health and network speed via Navigator.connection API. 3) Implement automatic quality downgrade when buffer < 5s, upgrade when buffer > 15s. 4) Store user manual quality preference in VideoProgress.qualityPreference. 5) Add quality adaptation events to analytics tracking. 6) Test with network throttling (3G, 4G, WiFi scenarios). 7) Add UI indicators for quality changes and buffering states.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3,
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Implement mobile-optimized video streaming",
            "description": "Optimize video playback for mobile devices with touch controls, reduced bandwidth usage, and native fullscreen support",
            "details": "1) Add touch gesture support to LessonVideoPlayer - double-tap to skip 10s forward/back, swipe up/down for volume, pinch for seeking. 2) Implement mobile-specific quality limits (max 720p on cellular, 1080p on WiFi). 3) Add Picture-in-Picture support for iOS Safari. 4) Optimize video preloading - reduce preload buffer on mobile to save bandwidth. 5) Add mobile-friendly UI - larger touch targets (44px minimum), simplified controls overlay. 6) Test on iOS Safari, Chrome Android, various screen sizes. 7) Add data saver mode toggle in settings.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3,
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Create comprehensive integration tests for video-lesson workflows",
            "description": "Build test suite covering end-to-end video streaming scenarios including enrollment, playback, progress tracking, and completion",
            "details": "Create src/__tests__/integration/video-lesson-integration.test.ts with tests: 1) Enrolled user can stream lesson video. 2) Unenrolled user receives 403 error. 3) Expired license blocks access. 4) Progress saves correctly every 30s. 5) Resume functionality works after page reload. 6) Lesson marks complete at 90% watch. 7) Course progress updates after lesson completion. 8) Bookmarks persist and sync. 9) Analytics data aggregates correctly. 10) Concurrent session limits enforced. Use Jest, React Testing Library, MSW for API mocking. Add E2E tests with Playwright for critical paths.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3,
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Implement video streaming performance optimizations and caching",
            "description": "Add Redis caching, video CDN integration, and performance monitoring to ensure smooth playback experience",
            "details": "1) Cache video metadata in Redis with 24h TTL - lesson video URLs, qualities, thumbnails. 2) Implement CDN integration for video delivery - use STREAMING_CONFIG.cdn.baseUrl. 3) Add video preloading - prefetch next lesson video when current reaches 80%. 4) Optimize database queries - add eager loading for lesson video data, use database indexes. 5) Implement stale-while-revalidate pattern for progress data. 6) Add performance monitoring - track video load time, time-to-first-frame, buffering events. 7) Create /api/video/health endpoint for monitoring. 8) Add metrics to Sentry/observability platform.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3,
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 4,
        "title": "Build Comprehensive Student Dashboard and Learning Experience",
        "description": "Create complete student interface for course discovery, enrollment, learning progress tracking, and achievement management",
        "details": "Develop student learning experience: 1) Personal dashboard showing enrolled courses, progress indicators, and recent activity 2) Course discovery with advanced filtering by engine (Unity/Unreal/Godot), difficulty, and categories 3) One-click enrollment flow with license key activation integration 4) Learning path visualization with prerequisite management 5) Achievement and certification system with blockchain credential integration 6) Study streak tracking and gamification elements 7) Course completion certificates with PDF generation 8) Social features for course discussions and peer interaction",
        "testStrategy": "Test student journey: discover and enroll in courses, track learning progress across multiple courses, earn achievements and certificates, interact with course discussions, verify all progress persists across sessions",
        "priority": "medium",
        "dependencies": [
          "1",
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Real-time Analytics Dashboard Integration",
            "description": "Convert mock charts in dashboard to real API data with interactive visualizations for weekly activity, skill progression, and learning trends",
            "details": "Replace hardcoded weeklyProgress and courseDistribution data in src/app/dashboard/page.tsx with real API calls. Create /api/dashboard/analytics endpoint to fetch user activity data, learning time, skill progression, and course distribution. Add interactive tooltips, zoom/pan on charts, and export chart data functionality. Use recharts with proper data transformation.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "AI-Powered Course Recommendation Engine",
            "description": "Build personalized course recommendation system based on user's completed courses, skill level, and learning goals",
            "details": "Create RecommendationsSection component displaying recommended courses on dashboard. Implement /api/courses/recommendations endpoint with collaborative filtering algorithm. Add skill gap analysis showing which courses fill knowledge gaps. Include career path templates (Unity Developer, Game Designer, etc.) with recommended course sequences.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Learning Streak System with Calendar Visualization",
            "description": "Replace hardcoded 7-day streak with real calculation and add calendar heatmap visualization similar to GitHub contributions",
            "details": "Create /api/progress/streak endpoint to calculate current streak from UserProgress records. Add streak recovery mechanics (1-day grace period). Implement calendar heatmap using react-calendar-heatmap showing daily learning activity. Add streak milestones (7, 30, 100 days) with badge rewards. Include push notification reminders for streak maintenance.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4,
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Interactive Progress Tracking with Module View",
            "description": "Add detailed lesson-by-lesson progress view with completion animations and predictive completion times",
            "details": "Create CourseProgressDetail component showing module/lesson tree with completion checkmarks. Add progress comparison charts (weekly/monthly/yearly views). Implement goal setting UI allowing users to set target completion dates. Calculate and display estimated time to complete based on learning velocity. Add confetti animation on module completion.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4,
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Advanced Search with Autocomplete and Wishlist",
            "description": "Enhance course discovery with autocomplete suggestions, search history, saved filters, and course wishlists",
            "details": "Add SearchAutocomplete component using Combobox from shadcn/ui. Create /api/courses/autocomplete endpoint returning suggestions for skills, instructors, topics. Implement search history stored in localStorage. Add save filter presets functionality. Create Wishlist model and /api/wishlist endpoints for bookmarking courses. Add course comparison tool showing side-by-side feature matrix.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4,
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Social Learning Hub with Forums and Study Groups",
            "description": "Implement discussion forums, study groups, and peer interaction features for collaborative learning",
            "details": "Create CourseDiscussions component with forum threads per course. Add study group creation UI with scheduling calendar. Implement /api/forums and /api/study-groups endpoints. Add real-time messaging using WebSocket or polling. Create project showcase gallery with voting and comments. Include mentor-mentee matching system based on skills and goals.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4,
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Achievement System with Leaderboards",
            "description": "Build real achievement tracking system with unlock animations, leaderboards, and XP progression",
            "details": "Create achievement unlock detection in /api/progress endpoints checking milestones. Add achievement unlock modal with celebration animation. Implement Leaderboard component showing top learners by course, global, and friends. Add XP and leveling system with level-up animations. Create badge collection gallery with rarity tiers (common, rare, epic, legendary). Include daily/weekly challenges.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4,
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Certificate Generation and Blockchain Verification",
            "description": "Implement course completion certificate generation with PDF export and blockchain credential verification",
            "details": "Create CertificateGenerator component using react-pdf or jsPDF. Design certificate templates with course info, student name, completion date, instructor signature. Add /api/certificates/generate endpoint creating Certificate records. Implement blockchain credential verification using digital signatures. Add certificate gallery view in dashboard. Include social sharing buttons for LinkedIn, Twitter with Open Graph meta tags. Generate QR codes for certificate verification.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4,
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Visual Learning Path Builder with Skill Trees",
            "description": "Create interactive learning path visualization showing course prerequisites and skill progression as tree diagrams",
            "details": "Build LearningPathVisualizer component using react-flow or D3.js showing courses as nodes with prerequisite connections. Add drag-and-drop custom path creator allowing users to build personalized learning sequences. Create career path templates (Unity Developer, Unreal Artist, Game Designer, Technical Artist) with pre-configured course sequences. Show progress tracking across entire learning path with completion percentages.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4,
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Dashboard Customization with Widget System",
            "description": "Implement drag-and-drop dashboard customization allowing users to personalize their learning hub layout",
            "details": "Create CustomizableDashboard component using react-grid-layout for drag-and-drop positioning. Add widget library (progress charts, recent activity, quick links, achievements, upcoming deadlines, recommendations). Implement dashboard layout persistence in user preferences. Add dark/light theme toggle with system preference detection. Create dashboard templates (student, professional, casual learner) for quick setup.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4,
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Streamlined Enrollment and Payment Flow",
            "description": "Optimize enrollment UX with streamlined checkout, license activation UI, and multi-course shopping cart",
            "details": "Create EnrollmentFlow component with step-by-step wizard (course selection, payment, confirmation). Integrate Dodo Payments with existing payment system. Add license key activation UI showing activation status and key details. Implement shopping cart for multiple course purchases with bundle discounts. Create payment history page showing past transactions. Add enrollment confirmation animations and email notifications. Include retry logic for failed payments with user-friendly error messages.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4,
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Mobile Responsiveness and PWA Features",
            "description": "Enhance mobile experience with optimized layouts, touch interactions, and progressive web app capabilities",
            "details": "Add bottom navigation bar for mobile devices replacing sidebar. Make all tabs swipeable using react-swipeable-views. Ensure all interactive elements meet 44px minimum touch target size. Create mobile-specific layouts for dashboard widgets and course cards. Implement PWA manifest and service worker for offline support. Add install prompt for iOS and Android. Optimize images with responsive srcset. Add pull-to-refresh functionality on mobile. Test with Chrome DevTools mobile emulation and real devices.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4,
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Game Engine Integration and Project Management",
        "description": "Build Unity, Unreal Engine, and Godot integration features for seamless project import/export and version control",
        "details": "Create game engine integrations: 1) Unity Hub integration with automatic project setup and package management 2) Unreal Engine .uproject file handling with Blueprint and C++ templates 3) Godot project structure support with GDScript integration 4) WebGL build pipeline for automatic game deployment and hosting 5) Version control integration (Git) with visual diff tools for binary assets 6) Asset management system with thumbnail previews and metadata 7) Project templates library for different game types 8) Cloud-based development environment setup with pre-configured engine versions",
        "testStrategy": "Verify engine integrations: create new projects in each engine, import/export projects successfully, WebGL builds deploy correctly, version control tracks changes properly, asset management functions across all supported engines",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Unity Engine Integration Service",
            "description": "Build Unity Hub integration with automatic project setup, package management, and version control support",
            "dependencies": [],
            "details": "Create Unity-specific services including: Unity project creation API endpoint (/api/engine/unity/projects), Unity Hub integration for automatic project setup with proper folder structure, Unity package manager integration for dependency management, Unity version detection and compatibility checking, Unity project file (.unityproject) parsing and manipulation, integration with existing video upload system for Unity tutorials, and WebGL build automation for Unity projects. Include proper validation for Unity project formats and asset handling.",
            "status": "pending",
            "testStrategy": "Unit tests for Unity project creation logic, integration tests for Unity Hub API calls, E2E tests for complete Unity project workflow from creation to WebGL deployment, performance tests for large Unity project handling",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Unreal Engine Project Management",
            "description": "Create Unreal Engine .uproject file handling with Blueprint and C++ template support",
            "dependencies": [
              "5.1"
            ],
            "details": "Build Unreal Engine integration including: .uproject file parsing and generation, Blueprint template library with common game patterns, C++ project template support with proper CMake configuration, Unreal Engine version compatibility checking, asset import/export functionality for Unreal projects, integration with existing course management system for Unreal tutorials, automated packaging for WebGL/HTML5 builds, and Visual Studio/Rider IDE integration setup. Support both Blueprint-only and C++ hybrid projects.",
            "status": "pending",
            "testStrategy": "Unit tests for .uproject file manipulation, integration tests for Blueprint template creation, E2E tests for C++ project compilation, compatibility tests across different Unreal Engine versions",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build Godot Engine Integration Framework",
            "description": "Develop Godot project structure support with GDScript integration and scene management",
            "dependencies": [
              "5.1"
            ],
            "details": "Create Godot-specific functionality including: Godot project.godot file handling, GDScript code analysis and syntax highlighting, Godot scene (.tscn) file management, Godot resource (.tres) file support, integration with Godot's built-in version control system, automated HTML5 export for web deployment, Godot plugin management and installation, and C# scripting support for Godot 4.x. Include proper validation for Godot project structure and asset references.",
            "status": "pending",
            "testStrategy": "Unit tests for GDScript parsing, integration tests for Godot project creation, E2E tests for HTML5 export pipeline, performance tests for large Godot project handling",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement WebGL Build Pipeline and Deployment",
            "description": "Create automated WebGL build system for Unity, Unreal, and Godot projects with hosting integration",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3"
            ],
            "details": "Build comprehensive WebGL deployment system including: automated build pipeline that detects engine type and uses appropriate build tools, WebGL optimization for different engines (Unity WebGL, Unreal HTML5, Godot HTML5), integration with existing video upload infrastructure for build artifacts, CDN deployment for optimized WebGL builds, build status tracking and logging, progressive loading implementation for large WebGL builds, and mobile-responsive WebGL container. Include build caching and incremental builds for faster iterations.",
            "status": "pending",
            "testStrategy": "Integration tests for each engine's WebGL build process, performance tests for build optimization, E2E tests for complete deployment pipeline, load testing for WebGL hosting infrastructure",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Git Integration and Asset Management System",
            "description": "Build version control integration with visual diff tools for binary assets and comprehensive asset management",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3"
            ],
            "details": "Implement advanced version control and asset management including: Git LFS integration for large binary assets (textures, models, audio), visual diff tools for images and 3D models using existing video processing infrastructure, automated asset thumbnail generation using video processing pipeline, metadata extraction for game assets (textures, audio, models), asset dependency tracking across projects, collaborative asset library with search and filtering, integration with existing portfolio system for asset showcasing, and automated asset optimization pipeline. Include proper handling of engine-specific assets (Unity .prefab, Unreal .uasset, Godot .tres files).",
            "status": "pending",
            "testStrategy": "Unit tests for Git LFS operations, integration tests for asset thumbnail generation, E2E tests for collaborative asset workflows, performance tests for large asset repository handling",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 6,
        "title": "Develop Real-Time Collaboration and Communication Features",
        "description": "Implement WebSocket-based real-time collaboration tools for multi-user code editing, voice chat, and project synchronization",
        "details": "Build collaboration infrastructure: 1) WebSocket server implementation for real-time communication 2) Multi-user code editor with operational transformation and conflict resolution 3) Voice and video chat integration using WebRTC 4) Real-time project synchronization with live cursors and user presence 5) Team management with role-based permissions (programmer, artist, designer) 6) Session recording for collaborative coding sessions 7) Screen sharing functionality for mentorship and debugging 8) Integrated chat with file sharing and code snippet support",
        "testStrategy": "Test collaboration features: multiple users edit code simultaneously without conflicts, voice/video chat functions reliably, project changes sync in real-time, session recordings capture all activities properly",
        "priority": "medium",
        "dependencies": [
          "4",
          "5"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Build scalable WebSocket signaling and real-time messaging layer",
            "description": "Implement an authenticated, horizontally scalable WebSocket service to power editor ops, presence, chat, and WebRTC signaling.",
            "dependencies": [],
            "details": "Select a runtime and library (e.g., Node.js with uWebSockets.js or Socket.IO). Implement JWT-based auth and room/channel multiplexing, with Redis/NATS pub-sub for fan-out across nodes. Add heartbeats, backpressure handling, ordered event delivery, and rate limiting. Define a versioned event schema for presence, cursor updates, document ops, chat, and WebRTC signaling. Enable TLS termination, structured logging, metrics (Prometheus), tracing (OpenTelemetry), and alerting. Provide SDKs/adapters for web and desktop clients.",
            "status": "pending",
            "testStrategy": "Load-test 1k–5k concurrent connections with 95th/99th percentile latency thresholds (<200ms). Fuzz malformed events and verify server resilience. Validate auth token expiry/revocation. Chaos-test node restarts and network partitions to ensure no message loss or duplication."
          },
          {
            "id": 2,
            "title": "Implement team management and role-based access control (RBAC)",
            "description": "Create team membership, invitations, and a permissions matrix for programmer, artist, and designer roles governing editing, chat, calls, screen share, and recording.",
            "dependencies": [
              "6.1"
            ],
            "details": "Extend data models for organizations/teams, projects, memberships, and roles. Define permission checks for actions (join room, edit file, start recording, share screen, manage collaborators). Enforce RBAC on the WebSocket gateway and HTTP APIs. Add invite/accept flows, role changes, audit logs, and presence visibility rules. Provide client-side guards and UI indicators for restricted actions.",
            "status": "pending",
            "testStrategy": "Unit-test permission gates for all critical actions. Integration-test invite/role-change flows and audit logging. Attempt forbidden actions from lower-privilege roles and verify denials. Validate presence visibility and room join restrictions."
          },
          {
            "id": 3,
            "title": "Deliver multi-user code editor with OT/CRDT, presence, and conflict resolution",
            "description": "Integrate a collaborative editor with real-time text ops, live cursors/selections, and robust conflict handling.",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Adopt Yjs (CRDT) or ShareDB (OT); prefer Yjs for offline support. Implement server adapters, document persistence, and snapshotting. Support multiple files/tabs, file-level awareness, live cursors with color/name labels, and selection ranges. Handle offline/online reconciliation, undo/redo across users, and semantic merges for common code edit patterns. Add syntax highlighting, basic language server hooks, and per-file permission checks.",
            "status": "pending",
            "testStrategy": "Simulate 10–20 concurrent editors producing interleaved keystrokes; verify eventual consistency and bounded latency. Property-based tests for concurrent inserts/deletes. Test offline edits and reconnection merges. Validate cursor/selection rendering and per-file permissions."
          },
          {
            "id": 4,
            "title": "Integrate WebRTC voice/video and screen sharing",
            "description": "Provide low-latency group calls with device controls and screen sharing, using WebSocket signaling and STUN/TURN.",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Set up STUN/TURN (coturn) and choose an SFU (e.g., LiveKit or mediasoup) for multi-party scaling. Implement signaling over the WebSocket layer, device selection, mute/unmute, and screen sharing via getDisplayMedia. Enable simulcast/SVC for bandwidth adaptation, echo cancellation, and noise suppression. Gate call join, screen share, and moderation controls via RBAC. Add connection quality indicators and automatic network recovery.",
            "status": "pending",
            "testStrategy": "Run cross-network call tests (NAT types, 5–15 participants). Inject 5–10% packet loss and confirm adaptive quality. Verify TURN fallback and successful screen sharing. Confirm RBAC blocks unauthorized sharing and kicking/muting controls work."
          },
          {
            "id": 5,
            "title": "Implement real-time project sync, integrated chat with file sharing, and session recording",
            "description": "Synchronize project file tree and status in real time, add threaded chat with attachments/snippets, and record collaborative sessions for playback.",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Design project-state synchronization (file tree updates, locks/intent-to-edit, rename/move, checkpoints) with conflict strategies and snapshots. Build chat with threads, mentions, reactions, code snippet formatting, and RBAC-governed file uploads (virus scanning, size/type limits). Implement session recording: timeline of editor ops/presence and optional A/V via SFU recording, with S3/Blob storage, metadata indexing, and playback UI that replays edits and media in sync. Add retention policies, access controls, and export/download options.",
            "status": "pending",
            "testStrategy": "Verify consistent file tree state across clients during concurrent rename/move/edit. Ensure exactly-once chat delivery and attachment scanning. Record multi-user sessions and validate synchronized playback of edits, presence, and A/V. Test retention and access enforcement on recordings."
          }
        ]
      },
      {
        "id": 7,
        "title": "Create Portfolio Showcase and WebGL Game Hosting System",
        "description": "Build comprehensive portfolio platform for students to showcase projects with integrated WebGL game hosting and social sharing",
        "details": "Implement portfolio showcase: 1) Portfolio builder with drag-and-drop layout customization 2) WebGL game hosting with embedded play experience and fullscreen support 3) Project gallery with high-resolution screenshots and video presentations 4) Social sharing integration with LinkedIn, Twitter, and professional networks 5) Employer portal for recruiter access and candidate discovery 6) Portfolio analytics showing view counts and engagement metrics 7) Custom domain support for professional portfolios 8) SEO optimization for portfolio discoverability",
        "testStrategy": "Verify portfolio functionality: students can create and customize portfolios, WebGL games play smoothly in browser, social sharing generates proper previews, employer portal provides good candidate filtering, portfolios are mobile-responsive",
        "priority": "medium",
        "dependencies": [
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Portfolio Platform Foundation (Data Model, APIs, Storage, Rendering)",
            "description": "Establish core backend and rendering stack for the portfolio system including schema, APIs, asset storage/CDN, routing, and baseline SEO-ready pages.",
            "dependencies": [],
            "details": "Define Prisma/ORM schema for UserProfile, Portfolio, Section, Project, MediaAsset, GameBuild, AnalyticsEvent, EmployerAccount; implement REST/GraphQL endpoints for CRUD with auth and role-based access (student, recruiter, admin); integrate object storage (S3/R2/GCS) with signed upload URLs, file integrity checks, and CDN caching; implement SSR/ISR portfolio and project pages with slugs and canonical URLs; set up image optimization pipeline and MIME configuration; implement permissions for private drafts vs public portfolios; add baseline SEO (title, meta, canonical, sitemap, robots.txt).",
            "status": "pending",
            "testStrategy": "Run migrations; create portfolios and projects via API; upload assets using signed URLs and verify CDN delivery; render SSR portfolio pages with correct data; validate canonical URLs and sitemap; confirm auth guards prevent draft access to anonymous users."
          },
          {
            "id": 2,
            "title": "Drag-and-Drop Portfolio Builder and Theming",
            "description": "Build WYSIWYG portfolio editor with drag-and-drop sections, reusable components, templates, theming, and publish workflow.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement grid-based layout editor using a11y-friendly drag-and-drop; provide section widgets (About, ProjectList, GameEmbed, Gallery, Video, Contact, SocialLinks); add theme system (color, typography, spacing, dark mode) with preset templates and custom CSS variables; enable real-time preview and autosave drafts with versioning and rollback; responsive breakpoints with per-section visibility; form validation and ARIA labels; publish flow toggling draft/public and generating stable URLs.",
            "status": "pending",
            "testStrategy": "Create a portfolio, add/reorder/remove sections, change theme, and publish; verify responsive layout on mobile/tablet/desktop; ensure autosave works and version rollback restores prior state; confirm a11y roles and keyboard interactions function; verify public view matches preview."
          },
          {
            "id": 3,
            "title": "WebGL Game Hosting and Embedded Play Experience",
            "description": "Implement secure hosting pipeline for Unity/Unreal/Godot WebGL builds with embedded iframe/player, fullscreen, and performance optimizations.",
            "dependencies": [
              "7.1"
            ],
            "details": "Support zipped build uploads with validation (manifest, index.html, wasm, data, framework); extract to storage with correct directory structure and MIME types; configure COOP/COEP and cross-origin isolation for SharedArrayBuffer where needed; enable WASM streaming and gzip/brotli; implement loading screen, progress events, and error handling; embed via sandboxed iframe or dedicated route with postMessage API; implement Fullscreen API, pointer lock, and gamepad support; add mobile fallback (screenshot/video + unsupported notice); set CORS and CSP headers; cache-control for static assets.",
            "status": "pending",
            "testStrategy": "Upload sample Unity, Unreal, and Godot builds; confirm they load with WASM streaming and no CORS/CSP errors; test fullscreen, pointer lock, and gamepad in Chrome/Firefox/Safari; validate performance budgets (TTI, memory) and caching; verify fallback on iOS or unsupported browsers."
          },
          {
            "id": 4,
            "title": "High-Resolution Project Gallery with Image/Video Pipeline",
            "description": "Create media pipeline for screenshots and video presentations with responsive delivery, lightbox, and accessibility.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement client-side chunked uploads with resumability; server-side processing to generate responsive image sets (AVIF/WebP/JPEG) and thumbnails; integrate video transcoding to HLS/DASH (or managed service) with multiple bitrates and poster frames; build gallery component with lightbox, captions, and keyboard navigation; add alt text, transcripts, and subtitles; enforce file size/type limits and EXIF stripping; CDN caching and signed URLs; integrate with projects in the builder.",
            "status": "pending",
            "testStrategy": "Upload large images and videos; verify responsive image sources and correct format negotiation; confirm HLS playback with adaptive bitrate and poster; test lightbox keyboard navigation and screen reader labels; measure CLS/visual stability and ensure thumbnails appear quickly."
          },
          {
            "id": 5,
            "title": "Social Sharing, SEO Enhancements, Employer Portal, Analytics, and Custom Domains",
            "description": "Integrate social share previews, advanced SEO, recruiter-facing portal with candidate discovery, engagement analytics, and custom domain mapping.",
            "dependencies": [
              "7.1",
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "Generate Open Graph/Twitter Card images per portfolio/project (dynamic OG image service) and oEmbed endpoint; add JSON-LD structured data (Person, CreativeWork, VideoObject, VideoGame); build employer portal with recruiter signup, role-based access, candidate search/filter (skills, engines, tags, location), saved lists, contact CTA/privacy controls; implement analytics events (views, shares, gallery opens, game play/complete) with server-side ingestion and per-portfolio dashboard; add cookie consent and GDPR/CCPA controls; implement custom domains with DNS verification (TXT/CNAME), automated SSL (ACME), and domain-to-portfolio routing with redirects; provide UTM tagging in share links and sitemap per custom domain.",
            "status": "pending",
            "testStrategy": "Validate share previews on LinkedIn/Twitter using their validators; check JSON-LD with Rich Results Test; run recruiter flows: search, filter, save candidates, and contact; simulate analytics events and verify dashboards and data retention policies; map a custom domain end-to-end (verify DNS, auto-issue SSL, route correctly, handle 404/redirects)."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Advanced Assessment and Certification System",
        "description": "Build comprehensive assessment tools with automated grading, peer review, and blockchain-based certification",
        "details": "Create assessment infrastructure: 1) Quiz builder with multiple question types (multiple choice, code completion, drag-and-drop) 2) Practical project assignments with automated testing and peer review 3) Code review system with instructor and peer feedback integration 4) Mock technical interview preparation with industry-standard questions 5) Portfolio defense scheduling with live presentation capabilities 6) Blockchain certificate generation with employer verification 7) Skill badge system for micro-credentials 8) Integration with Unity, Epic Games, and industry certification programs",
        "testStrategy": "Test assessment system: create and take quizzes with various question types, submit practical projects for review, receive meaningful feedback, earn certificates that verify on blockchain, skill badges display correctly in profiles",
        "priority": "medium",
        "dependencies": [
          "4",
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Build Assessment Core and Quiz Builder",
            "description": "Implement the foundational assessment service and quiz builder supporting multiple question types, auto-grading, item banks, attempts, and analytics.",
            "dependencies": [],
            "details": "Deliver a service-oriented assessment core (assessment-core, grading-service) with PostgreSQL schemas for Questions, QuestionPools, Quizzes, Attempts, Responses, Rubrics, and Outcomes. Support question types: multiple choice (single/multi), code completion (Monaco editor, language-aware templates), drag-and-drop ordering/matching, and short answer. Add features: randomization (item pools, shuffling), time limits, per-question timers, attempt caps, accommodations, and WCAG 2.1 AA accessibility. Provide React/TypeScript quiz builder UI with rich validation, preview mode, and versioning. Implement auto-grading pipelines for objective items and pluggable graders for code-completion via a sandbox runner API. Include item tagging, difficulty calibration, and item analysis (discrimination, difficulty).",
            "status": "pending",
            "testStrategy": "Unit-test grading functions and validators; property-based tests for scoring edge cases; cross-browser E2E tests for quiz creation, preview, and delivery; accessibility tests (axe, keyboard navigation); performance tests for large item pools; data integrity tests for attempts and versioning."
          },
          {
            "id": 2,
            "title": "Practical Projects: Automated Testing and Peer Review",
            "description": "Create practical assignment workflows with containerized automated testing, plagiarism detection, and calibrated peer review.",
            "dependencies": [
              "8.1"
            ],
            "details": "Implement assignment submissions via Git repo (GitHub/GitLab) or archive upload; define test harness contracts (language-agnostic) with adapters for Python/pytest, JS/Jest, Java/JUnit, C#/NUnit. Build a secure sandbox runner using Docker with cgroups, seccomp, gVisor, resource quotas, and timeouts. Capture logs, artifacts, code coverage, and test reports (JUnit XML). Add plagiarism detection (code similarity via token-based and AST-based comparison, MOSS-style) with thresholds and instructor override. Design calibrated peer review: reviewer assignment, double-blind workflow, rubric templates, calibration rounds with gold standards, reputation weighting, and moderation/appeal flow. Integrate auto and peer scores into a composite grade policy.",
            "status": "pending",
            "testStrategy": "Integration tests running sample repos through runner across languages; security tests for sandbox escape attempts; deterministic grading regression tests; simulation tests for peer review assignment, calibration accuracy, and bias checks; plagiarism detection precision/recall benchmarking; E2E tests from assignment creation to graded outcome."
          },
          {
            "id": 3,
            "title": "Code Review System and Mock Technical Interviews",
            "description": "Deliver inline code review with instructor/peer feedback and a mock interview module using industry-standard questions and coding challenges.",
            "dependencies": [
              "8.1"
            ],
            "details": "Build a code review UI with side-by-side and unified diffs, syntax highlighting, inline comments, threads, suggestions, and approval states; support file-level and overall feedback, and exportable review reports. Add rubric scoring and integration with assignment artifacts from submissions. Implement a mock interview module: curated bank of data structures/algorithms, system design prompts, and behavioral questions; timed coding pad with Monaco + test cases; structured scoring rubrics and competency mapping. Provide interviewer dashboard (question selection, timers, notes), candidate view, transcripts, and analytics (time-to-first-keystroke, test pass rate). Enable scheduling and proctoring hooks for live or asynchronous sessions.",
            "status": "pending",
            "testStrategy": "Snapshot tests for diff rendering; unit tests for comment threading and permissions; E2E flows for review creation, feedback integration, and rubric scoring; mock interview dry-runs with timing and auto-test evaluation; reliability tests for autosave and reconnection; content QA for question bank coverage."
          },
          {
            "id": 4,
            "title": "Portfolio Defense Scheduling and Live Presentation",
            "description": "Provide scheduling, panel management, and live presentation capabilities with recording and rubric-based scoring for portfolio defenses.",
            "dependencies": [
              "8.1"
            ],
            "details": "Implement a scheduling system with timezone handling, slot generation, capacity limits, conflict detection, rescheduling, and ICS invites; integrate with Google/Microsoft calendars via OAuth. Build live presentation rooms using a WebRTC SFU (e.g., LiveKit/mediasoup) with screensharing, whiteboard, chat, waiting room, and role-based permissions (host, panelist, candidate). Enable session recording with cloud storage, metadata tagging, and consent capture. Provide real-time panel scoring using shared rubrics, per-criterion notes, and lock/submit flow; generate defense reports and link to learner profiles. Add accessibility features (live captions, keyboard controls) and backup dial-in links.",
            "status": "pending",
            "testStrategy": "E2E tests for slot booking, reminders, and rescheduling; cross-browser WebRTC tests for AV, screenshare, and network resilience; load tests for concurrent sessions; recording integrity checks; rubric scoring concurrency tests; accessibility and caption accuracy validation."
          },
          {
            "id": 5,
            "title": "Blockchain Certificates, Employer Verification, and Skill Badges (with Industry Integrations)",
            "description": "Issue verifiable blockchain-backed certificates and micro-credential badges, with an employer verification portal and integrations with Unity/Epic and industry certifications.",
            "dependencies": [
              "8.1",
              "8.2",
              "8.3",
              "8.4"
            ],
            "details": "Design a verifiable credential pipeline: issue non-transferable certificates as NFTs (EIP-5192) on Polygon or as Ethereum Attestation Service (EAS) attestations; store metadata (schema, evidence, rubric outcomes, hashes) on IPFS/Arweave; support revocation and re-issuance. Implement Open Badges v3-compliant skill badges tied to granular outcomes; display in learner profiles and export as JSON-LD. Build an employer verification portal + API: QR codes, on-chain proof verification, cryptographic checks of metadata hashes, and privacy controls (selective disclosure). Provide walletless issuance via custodial wallets or email-based claim links; allow wallet binding later. Map certificate issuance rules to completion across quizzes, projects, code reviews, interviews, and defenses. Add integrations: accept/import results from Unity/Epic Games and industry programs via LTI 1.3/OAuth webhooks; expose outbound verification for employers and partner platforms.",
            "status": "pending",
            "testStrategy": "Smart contract unit tests and testnet deployments (Mumbai/Amoy); verification portal integration tests with valid/invalid proofs; revocation and re-issuance tests; IPFS pinning reliability checks; security audits (replay, phishing, PII leakage); end-to-end issuance after learner completes prerequisites; badge rendering in profile and external wallet compatibility checks."
          }
        ]
      },
      {
        "id": 9,
        "title": "Build Community Features and Social Learning Platform",
        "description": "Implement comprehensive community tools including forums, study groups, game jams, and mentorship matching",
        "details": "Develop community platform: 1) Discussion forums with course-specific threads and instructor participation 2) Study group formation with progress tracking and accountability features 3) Game jam hosting platform with theme announcements and submission systems 4) Mentorship matching algorithm connecting experienced developers with learners 5) Developer showcase events highlighting exceptional student work 6) Community leaderboards and recognition systems 7) Interest-based groups for specialized topics (VR, mobile, indie development) 8) Content curation system for community-generated tutorials and resources",
        "testStrategy": "Verify community features: forums enable meaningful discussions, study groups form and track progress effectively, game jam submissions work smoothly, mentorship matching creates valuable connections, community events generate engagement",
        "priority": "low",
        "dependencies": [
          "6",
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Course-specific discussion forums with instructor participation",
            "description": "Build course-linked forums enabling threads, replies, rich text, tagging, search, moderation, and instructor-highlighted answers to foster structured Q&A and discussions.",
            "dependencies": [],
            "details": "Implement data model (Forum per course, Thread, Post, Tag, Subscription, Vote, ModerationQueue); features include WYSIWYG/Markdown editor with code blocks and attachments (virus scanning), mentions (@), thread pin/lock/merge, accepted answers/solved state, instructor/TA badges, rate limiting and spam detection, full-text search, notifications (web/email), and accessibility (ARIA). Provide RBAC (instructor, TA, student, moderator) with audit logs, REST/GraphQL APIs, pagination/infinite scroll, and analytics events for engagement tracking.",
            "status": "pending",
            "testStrategy": "E2E tests for thread create/reply/edit/delete flows; permission and moderation actions; subscription/notification delivery; spam detection thresholds and false-positive checks; search relevancy tests; performance tests with 10k+ posts and 1k concurrent users; accessibility checks for keyboard navigation and screen readers."
          },
          {
            "id": 2,
            "title": "Study groups with progress tracking and accountability",
            "description": "Enable learners to create or join study groups with synced course progress, shared goals, check-ins, scheduling, and lightweight group communications to drive accountability.",
            "dependencies": [],
            "details": "Design data model (StudyGroup, Membership, GroupGoal, CheckIn, Meeting, Announcement). Implement group creation with size caps and privacy settings, invite links, timezone-aware scheduling with calendar export (iCal/Google), reminders, streaks/attendance tracking, group dashboard aggregating member progress from course progress APIs, lightweight chat or threaded updates, nudges for inactivity, and safe exit/report flows. Provide notifications, moderation escalation, and analytics on group health and retention.",
            "status": "pending",
            "testStrategy": "Verify group creation/join/leave and capacity constraints; progress sync correctness versus individual course progress; scheduling across timezones; reminder delivery and opt-out; chat persistence and rate limiting; concurrency tests when multiple users join the last slot; retention analytics event tracking."
          },
          {
            "id": 3,
            "title": "Game jam hosting and submission platform",
            "description": "Provide end-to-end game jam support including theme announcements, team formation, submissions, judging/voting, and results with anti-abuse protections.",
            "dependencies": [],
            "details": "Create data model (JamEvent, Theme, Team, Member, Submission, BuildArtifact, Rating, Judge, Rule). Build jam creation wizard (rules, dates, categories), countdown and theme announcement, LFG/team formation, submission portal with large file uploads, checksum and virus scan, visibility controls, judging modes (public, judges, weighted), rating and tie-break logic, results and badges. Integrate CDN delivery for builds, storage quotas, takedown/abuse workflows, and forum integration for jam threads.",
            "status": "pending",
            "testStrategy": "Time-gating tests for submission windows and theme reveal; team join/leave edge cases and capacity; resumable large file uploads with size/type validation and scans; rating aggregation correctness and tie-breakers; anti-cheat checks (duplicate accounts/IP anomalies); result publication and badge assignment verification; load tests for submission deadline spikes."
          },
          {
            "id": 4,
            "title": "Mentorship matching and session management",
            "description": "Implement mentor/mentee profiles, matching algorithm based on skills/goals/availability, and session booking, messaging, and feedback workflows.",
            "dependencies": [],
            "details": "Define data model (MentorProfile with verification, MenteeProfile, Match, Session, Feedback, Report). Build multi-factor scoring (skills, goals, timezone, language, availability), constraints (mentor capacity), and matching algorithm (Hungarian/bipartite or greedy thresholds) with explainable scores and approval flows. Provide scheduling with conflict checks, reminders, in-platform messaging, session notes and goals, feedback requests, code of conduct acknowledgments, privacy controls, and safeguarding/reporting.",
            "status": "pending",
            "testStrategy": "Unit tests for score computation and constraint handling; simulation with synthetic profiles to evaluate match quality and fairness; booking conflict detection and calendar overlaps; messaging delivery and retention; feedback capture and analytics; abuse/report workflows and escalation paths."
          },
          {
            "id": 5,
            "title": "Community discovery, recognition, and content curation",
            "description": "Launch interest-based groups, leaderboards and badges, developer showcase events, and a curated repository of community-generated tutorials and resources.",
            "dependencies": [
              "9.1",
              "9.2",
              "9.3",
              "9.4"
            ],
            "details": "Interest groups: creation/joining, topic tags (VR, mobile, indie), group feeds, moderators, cross-posts from forums and jams. Recognition: unified point system across activities (forum contributions, accepted answers, study group streaks, jam participation, mentorship), badges and levels, time-bounded leaderboards with anti-gaming checks and cooldowns. Showcases: periodic events with submission, editorial/judge review, featured highlights on homepage/newsletter, archival gallery. Curation: submission pipeline for tutorials/resources, reviewer workflow, metadata tagging and search, trust/quality scores, and takedown/reporting. Include analytics dashboards and A/B testing for incentive tuning.",
            "status": "pending",
            "testStrategy": "Validate leaderboard calculations, decay windows, and badge issuance across activity types; anti-gaming rules and anomaly detection; group creation/moderation flows and content policies; end-to-end showcase event lifecycle (announce, submit, review, publish); curation workflow state transitions and search relevance; email/newsletter digests and homepage highlights rendering."
          }
        ]
      },
      {
        "id": 10,
        "title": "Optimize Performance and Complete Production Deployment",
        "description": "Implement performance optimizations, comprehensive monitoring, and complete production deployment with global CDN integration",
        "details": "Production optimization and deployment: 1) Performance optimization with bundle analysis and code splitting 2) CDN integration for global asset delivery with 100+ edge locations 3) Database query optimization and connection pooling 4) Comprehensive monitoring with Sentry error tracking and performance metrics 5) Load testing with simulated 10,000+ concurrent users 6) Security audit including penetration testing and vulnerability scanning 7) WCAG 2.1 AA accessibility compliance verification 8) Mobile app preparation with PWA features and offline capabilities 9) Analytics integration for user behavior tracking and conversion optimization",
        "testStrategy": "Verify production readiness: platform handles expected load without performance degradation, global CDN delivers content sub-50ms latency, monitoring alerts function properly, security audit passes all checks, accessibility compliance verified with automated and manual testing",
        "priority": "medium",
        "dependencies": [
          "7",
          "8",
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Frontend performance optimization and PWA offline readiness",
            "description": "Optimize web bundles, assets, and runtime for fast, reliable user experience and enable PWA offline capabilities.",
            "dependencies": [],
            "details": "Conduct bundle analysis with Webpack Bundle Analyzer or Vite analyze. Implement route and component level code splitting using dynamic imports, enable tree shaking, and reduce vendor size by removing unused locales and heavy libraries. Optimize images with AVIF and WebP, responsive srcset, lazy loading, and preconnect to CDN; extract critical CSS, purge unused CSS, and minify. Limit polyfills using usage based targets. Enable Brotli and gzip compression and versioned filenames for cache busting. Implement PWA using Workbox with CacheFirst for immutable assets and StaleWhileRevalidate for safe resources, offline fallback page, background sync for queued writes, and a complete web app manifest with icons. Targets: Lighthouse performance 90 plus, LCP under 2.5 s, CLS under 0.1, TTI under 3 s on 4G mid tier device.",
            "status": "pending",
            "testStrategy": "Run Lighthouse CI across key pages; compare baseline vs optimized bundle sizes and timings. Validate service worker registration, offline navigation, and cache behavior in Chrome DevTools. Verify correct preloading and lazy loading. Test across modern browsers and low end mobile to confirm targets met."
          },
          {
            "id": 2,
            "title": "Backend and database performance optimization",
            "description": "Profile and optimize database queries, indexing, caching, and connection pooling to reduce latency and improve throughput.",
            "dependencies": [],
            "details": "Enable pg stat statements and profile hot queries with EXPLAIN ANALYZE; add or adjust composite and partial indexes to achieve index only scans where possible. Remove N plus 1 with ORM eager loading and batching. Introduce Redis caching for hot reads with appropriate TTL and cache invalidation on writes; leverage ETag and 304 for idempotent GET endpoints. Configure pgbouncer for connection pooling and size pools based on database max connections and app instances; set sensible statement timeout and lock timeout. Prefer prepared statements and keyset pagination on large datasets. Offload long running tasks to background workers. Targets: reduce P95 API latency, keep DB CPU under 70 percent, and pool saturation under 80 percent.",
            "status": "pending",
            "testStrategy": "Create repeatable load scripts and capture before and after P95 and P99 latency and throughput. Add query level regression tests for execution time thresholds. Validate cache hit rates and eviction behavior. Monitor slow query log to ensure reductions persist."
          },
          {
            "id": 3,
            "title": "Global CDN integration and production deployment pipeline",
            "description": "Integrate a CDN with 100 plus edge locations and implement a robust CI CD pipeline for safe production deployments.",
            "dependencies": [
              "10.1",
              "10.2"
            ],
            "details": "Select and configure CDN such as Cloudflare, Fastly, or Akamai. Point DNS to CDN, enable TLS with HTTP 3 and HSTS, and configure origin shielding and health checks. Create cache policies with long TTL for versioned immutable assets and short TTL for HTML; normalize cache keys and ignore cookies for static assets. Automate asset upload to object storage and CDN purges via CI after deploy. Enable edge compression and image optimization where available. Implement blue green or canary releases with automated smoke tests and rollback; manage infrastructure as code with Terraform. Targets: edge TTFB under 50 ms for cached assets and cache hit ratio above 90 percent.",
            "status": "pending",
            "testStrategy": "Use global synthetic probes to measure TTFB and cache hit ratio from multiple regions. Validate cache keys, headers, and invalidation. Execute canary deploy and forced rollback drill. Run post deploy smoke tests through CDN endpoints."
          },
          {
            "id": 4,
            "title": "Observability, monitoring, and analytics instrumentation",
            "description": "Implement comprehensive error tracking, tracing, metrics, logs, alerting, and analytics with privacy controls.",
            "dependencies": [
              "10.3"
            ],
            "details": "Integrate Sentry for error tracking and performance with source map upload and calibrated sample rates. Instrument services with OpenTelemetry, propagate W3C trace context, and export traces to Jaeger or Tempo; correlate Sentry transactions with traces. Expose application and infrastructure metrics to Prometheus and build Grafana dashboards; define SLIs and SLOs with error budgets. Centralize structured logs in OpenSearch or ELK with correlation IDs and retention policies. Configure alerts to Slack or PagerDuty for latency, error rate, saturation, and heartbeats; document runbooks. Add synthetic monitoring and real user monitoring. Implement analytics via GA4 or Segment to Amplitude with an event taxonomy, consent management CMP, data minimization, and conversion tracking.",
            "status": "pending",
            "testStrategy": "Trigger test exceptions and latency spikes to verify Sentry events, traces, and alerts. Validate Grafana dashboards update in real time. Confirm synthetic checks and RUM data collection. Verify analytics events flow end to end with consent states respected and no PII leakage."
          },
          {
            "id": 5,
            "title": "Validation: load testing at scale, security audit, and accessibility compliance",
            "description": "Execute load tests for 10,000 plus concurrent users, complete security auditing including pentest and vulnerability scanning, and verify WCAG 2.1 AA compliance.",
            "dependencies": [
              "10.3",
              "10.4"
            ],
            "details": "Perform load testing with k6 or Locust using realistic traffic mix across CDN cached assets and APIs; include ramp, spike, and soak scenarios targeting 10k concurrent users. Correlate results with observability to find bottlenecks. Acceptance: P95 API latency within target, error rate under 0.1 percent, no memory leaks or pool exhaustion, CDN cache hit ratio above 90 percent. Conduct security checks including SAST with CodeQL, dependency scanning with Snyk or native tooling, DAST with OWASP ZAP, secrets scanning, and schedule an external penetration test; remediate critical and high findings. Validate security headers and controls including CSP, HSTS, Referrer Policy, X Frame Options, Permissions Policy, WAF rules, and rate limiting. Verify accessibility with automated axe core and Lighthouse audits plus manual keyboard only and screen reader testing with NVDA and VoiceOver; fix issues and publish a WCAG 2.1 AA conformance report.",
            "status": "pending",
            "testStrategy": "Publish a load test report with P95 and P99 latency, throughput, error rates, and resource utilization meeting acceptance criteria. Provide a security audit report with all critical and high issues resolved and headers verified. Deliver an accessibility report demonstrating WCAG 2.1 AA compliance with zero critical violations."
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement video upload interface for instructors",
        "description": "Create drag-and-drop video upload interface with chunked upload support and progress tracking for instructor course creation",
        "details": "Build React component using FileReader API for chunked uploads to /api/video/upload endpoint. Implement progress tracking with useState for upload percentage, drag-and-drop zone using onDrop handlers, file validation for video formats (mp4, webm, mov), and upload queue management. Integrate with existing instructor course creation flow and add video metadata extraction (duration, size, format). Use FormData for multipart uploads and handle upload resumption on failure.",
        "testStrategy": "Unit tests for file validation logic, integration tests for upload API endpoint, E2E tests for complete upload workflow, and performance tests with large video files",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create drag-and-drop upload component with react-dropzone",
            "description": "Build React component with drag-and-drop zone using react-dropzone library for intuitive file selection",
            "dependencies": [],
            "details": "Create VideoUploadZone component using react-dropzone with visual feedback for drag states, accept only video formats (mp4, webm, mov), implement file size validation (max 2GB), add styled drop zone with clear upload instructions and visual indicators for drag hover states",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T19:12:14.531Z"
          },
          {
            "id": 2,
            "title": "Implement chunked upload with FileReader API and progress tracking",
            "description": "Build chunked upload mechanism using FileReader API with real-time progress tracking",
            "dependencies": [
              "11.1"
            ],
            "details": "Implement chunked upload logic using FileReader to split large video files into 5MB chunks, create progress tracking with useState for upload percentage, add FormData for multipart uploads, implement upload resumption on failure using chunk checksums, provide real-time upload speed and ETA calculations",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T19:13:54.124Z"
          },
          {
            "id": 3,
            "title": "Add file validation and video metadata extraction",
            "description": "Implement comprehensive file validation and extract video metadata for processing",
            "dependencies": [
              "11.2"
            ],
            "details": "Validate video file formats, size limits, and duration constraints, extract video metadata (duration, resolution, bitrate, codec) using video element or library, implement file type checking using MIME types and file headers, add validation for maximum duration (e.g., 4 hours) and minimum quality requirements",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T19:13:54.126Z"
          },
          {
            "id": 4,
            "title": "Build upload queue management and error handling",
            "description": "Create upload queue system for managing multiple video uploads with comprehensive error handling",
            "dependencies": [
              "11.3"
            ],
            "details": "Implement upload queue with ability to upload multiple videos simultaneously, add retry logic for failed uploads with exponential backoff, create upload status management (queued, uploading, processing, completed, failed), implement pause/resume functionality, add detailed error messages and recovery suggestions",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T19:13:54.127Z"
          },
          {
            "id": 5,
            "title": "Integrate with instructor course creation flow",
            "description": "Connect video upload component to existing instructor course management interface",
            "dependencies": [
              "11.4"
            ],
            "details": "Integrate VideoUploadZone component into lesson creation forms, connect uploaded videos to lesson content, implement video thumbnail generation and preview, add video management (replace, delete) in lesson editor, ensure proper data flow between upload component and course creation state, add video processing status indicators",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-02T19:14:41.054Z"
          }
        ],
        "updatedAt": "2025-10-02T19:14:41.054Z"
      },
      {
        "id": 12,
        "title": "Enhanced video player with advanced controls",
        "description": "Add picture-in-picture, playback speed controls, keyboard shortcuts, and quality selector to existing video player component",
        "details": "Extend src/components/video/video-player.tsx with Picture-in-Picture API support, speed controls (0.5x-2x), keyboard event handlers (space for play/pause, arrow keys for seek), quality selector dropdown using HTMLVideoElement.videoTracks, closed captions support with WebVTT, and fullscreen API integration. Implement video thumbnail preview on seek using canvas for frame extraction and localStorage for resume position tracking.",
        "testStrategy": "Unit tests for keyboard handlers and control logic, visual regression tests for UI controls, cross-browser compatibility testing, and accessibility testing with screen readers",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Module and lesson management interface",
        "description": "Create comprehensive module and lesson management UI with drag-and-drop reordering and content editor",
        "details": "Build React components using @dnd-kit/sortable for drag-and-drop module reordering, rich text editor with @tiptap/react for lesson content, lesson type selection (video, quiz, reading, project), module creation form with validation, bulk lesson import functionality via CSV/JSON, and lesson duration estimation calculator. Integrate with existing API endpoints /api/courses/[id]/modules and lessons endpoints.",
        "testStrategy": "Unit tests for drag-and-drop logic, integration tests for module/lesson CRUD operations, E2E tests for complete content creation workflow, and performance tests with large content datasets",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Database optimization and indexing",
        "description": "Add database indexes for common query patterns and optimize N+1 queries in Prisma schema",
        "details": "Analyze prisma/schema.prisma for index opportunities on Course.category, User.role, Enrollment.userId/courseId, Progress.userId/lessonId, and Payment.status fields. Implement Prisma include statements optimization to prevent N+1 queries in course listings and user enrollments. Add database connection pooling configuration in DATABASE_URL and implement query performance monitoring using Prisma metrics. Create database migration files using prisma migrate dev.",
        "testStrategy": "Performance benchmarks before/after optimization, query analysis with EXPLAIN ANALYZE, load testing with concurrent users, and monitoring query execution times",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-02T19:35:10.666Z"
      },
      {
        "id": 15,
        "title": "API route standardization and documentation",
        "description": "Standardize error responses, add request logging, and create OpenAPI documentation for all 70+ API endpoints",
        "details": "Create standardized error response schema with code, message, details fields. Implement middleware for request/response logging using next/server RequestInit. Add rate limiting using @upstash/ratelimit with Redis or in-memory store. Generate OpenAPI/Swagger documentation using @apidevtools/swagger-jsdoc and serve via /api/docs endpoint. Implement request ID tracking using crypto.randomUUID() and add response time headers.",
        "testStrategy": "API contract testing with generated OpenAPI spec, rate limiting verification tests, error response format validation, and performance impact assessment of logging",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-03T03:18:07.476Z"
      },
      {
        "id": 16,
        "title": "Comprehensive security audit and hardening",
        "description": "Implement OWASP Top 10 protections, input sanitization, and security headers across the platform",
        "details": "Add Content Security Policy headers in next.config.ts, implement DOMPurify for user input sanitization, add CSRF protection using @edge-runtime/cookies, implement SQL injection prevention with Prisma parameterized queries, add XSS prevention with output encoding, implement authentication brute force protection with rate limiting, and create security monitoring dashboard. Configure security headers (HSTS, X-Frame-Options, X-Content-Type-Options).",
        "testStrategy": "Automated security scanning with tools like npm audit, manual penetration testing, OWASP ZAP scanning, input validation testing, and security header verification",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-03T03:28:47.588Z"
      },
      {
        "id": 17,
        "title": "Responsive design and mobile optimization",
        "description": "Complete mobile experience audit and optimization for all breakpoints (320px-1024px+)",
        "details": "Audit all 45+ components for mobile responsiveness using Tailwind responsive prefixes (sm:, md:, lg:, xl:). Implement mobile-specific navigation patterns with slide-out menu, optimize touch targets to 44x44px minimum, fix layout overflow issues with proper flex/grid constraints, test on iOS Safari and Android Chrome for compatibility, and implement mobile-specific video player controls with larger touch targets.",
        "testStrategy": "Cross-device testing on physical devices, browser dev tools responsive testing, automated responsive design testing with Playwright, and user experience testing on mobile devices",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit existing components for mobile responsiveness",
            "description": "Systematically review all 45+ components for mobile compatibility and document issues",
            "dependencies": [],
            "details": "Go through each component in src/components/ and test responsiveness at breakpoints 320px, 768px, 1024px. Check for proper Tailwind responsive prefixes (sm:, md:, lg:, xl:), overflow issues, text readability, and component functionality on mobile. Document all issues in a spreadsheet for tracking.\n<info added on 2025-10-03T03:37:52.842Z>\nI need to analyze the codebase structure to better understand the mobile responsiveness audit findings mentioned in the user request.Mobile responsiveness audit completed successfully. Comprehensive analysis of 9 core components across 320px, 768px, 1024px, and 1280px breakpoints revealed mixed responsiveness implementation with critical issues requiring immediate attention.\n\nAUDIT RESULTS SUMMARY:\n- Total components audited: 9 core components + 3 pages\n- Issues identified: 27 total (5 critical, 15 medium, 7 minor)\n- Overall mobile responsiveness score: 6/10\n\nCRITICAL FINDINGS:\n1. Video Player Controls (src/components/video/video-player.tsx): ALL control buttons use size=\"sm\" with h-4 w-4 icons, resulting in ~32x32px touch targets - significantly below the 44x44px WCAG minimum requirement. Volume slider at w-20 (80px) width also insufficient for accurate touch interaction.\n\n2. Touch Target Violations: Multiple components have interactive elements below 44x44px minimum, particularly video controls, some course card buttons, and navigation menu toggle.\n\nPOSITIVE FINDINGS:\n1. MainNav component (src/components/layout/main-nav.tsx) demonstrates EXCELLENT mobile implementation: proper responsive breakpoints (hidden md:flex), mobile Sheet menu with 300px-400px width, appropriate auth button handling with hidden sm:flex pattern.\n\n2. Most page layouts use proper responsive grid patterns (md:grid-cols-X lg:grid-cols-Y) and Tailwind responsive prefixes effectively.\n\nLAYOUT ISSUES IDENTIFIED:\n1. Dashboard page TabsList uses grid-cols-4 without mobile breakpoint, causing cramped display on 320px screens\n2. Hero section stats grid uses grid-cols-3 without responsive adjustment\n3. Course page featured categories could benefit from grid-cols-1 sm:grid-cols-2 pattern\n\nTYPOGRAPHY CONCERNS:\nFixed font sizes (text-4xl, text-3xl, heading-hero) lack responsive scaling for mobile readability. Recommended responsive classes: text-2xl sm:text-3xl md:text-4xl pattern.\n\nDetailed audit report with component-specific analysis, touch target measurements, and implementation recommendations documented at .taskmaster/docs/mobile-responsiveness-audit.md. Next priority: Subtask 17.3 (touch targets) and 17.5 (video player mobile optimization) require immediate attention before production deployment.\n</info added on 2025-10-03T03:37:52.842Z>",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-03T03:38:01.909Z"
          },
          {
            "id": 2,
            "title": "Implement mobile-specific navigation with slide-out menu",
            "description": "Create mobile navigation pattern replacing desktop navigation on small screens",
            "dependencies": [
              "17.1"
            ],
            "details": "Design and implement a slide-out mobile menu using shadcn/ui components. Include hamburger menu button, smooth animations, proper z-index layering, and accessibility features. Ensure it works across all authenticated and unauthenticated pages.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-03T03:47:56.546Z"
          },
          {
            "id": 3,
            "title": "Optimize touch targets to 44x44px minimum",
            "description": "Ensure all interactive elements meet mobile touch target size requirements",
            "dependencies": [
              "17.1"
            ],
            "details": "Review all buttons, links, form inputs, and interactive elements to ensure minimum 44x44px touch target size. Update Tailwind classes to add proper padding/margin. Focus on course cards, video controls, navigation elements, and form components.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-03T03:47:58.872Z"
          },
          {
            "id": 4,
            "title": "Fix layout overflow issues with proper flex/grid constraints",
            "description": "Resolve horizontal scrolling and layout breaking issues on mobile devices",
            "dependencies": [
              "17.1"
            ],
            "details": "Identify and fix all layout overflow issues using proper Tailwind flex and grid utilities. Ensure content stays within viewport bounds, implement proper text wrapping, and fix any horizontal scrolling issues. Focus on course grids, dashboard layouts, and content areas.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-03T03:48:00.907Z"
          },
          {
            "id": 5,
            "title": "Optimize video player for mobile devices",
            "description": "Implement mobile-specific video player controls and touch interactions",
            "dependencies": [
              "17.3"
            ],
            "details": "Create mobile-optimized video player controls with larger touch targets, fullscreen support, proper orientation handling, and mobile-specific gestures. Ensure video streaming performance is optimized for mobile networks and battery usage.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-03T03:48:02.805Z"
          },
          {
            "id": 6,
            "title": "Test responsiveness on iOS Safari and Android Chrome",
            "description": "Comprehensive cross-browser mobile testing and bug fixes",
            "dependencies": [
              "17.2",
              "17.3",
              "17.4",
              "17.5"
            ],
            "details": "Test the platform on actual iOS Safari and Android Chrome browsers using browser dev tools and physical devices. Document any browser-specific issues, viewport meta tag problems, or touch interaction bugs. Fix any compatibility issues found.\n<info added on 2025-10-03T03:51:06.510Z>\nI'll analyze the codebase to understand the project structure and provide a comprehensive update for the mobile testing subtask.Mobile testing guide document created at .taskmaster/docs/mobile-testing-guide.md contains comprehensive testing procedures for iOS Safari and Android Chrome. The guide includes detailed checklists covering touch target verification (44px minimum requirement), layout testing across breakpoints, typography readability assessment, video player mobile UX evaluation, performance benchmarking, accessibility validation, and browser-specific compatibility checks. Document provides structured testing priority phases (Critical Path, Layout & Overflow, UX Polish, Edge Cases), acceptance criteria for production readiness, bug reporting templates, and post-testing action items. All key responsive breakpoints and mobile-specific implementation details are documented with specific file references including video player controls (src/components/video/video-player.tsx) and dashboard responsive grid layouts (grid-cols-2 sm:grid-cols-4). Testing guide serves as comprehensive framework for validating mobile responsiveness implementation before marking subtask complete.\n</info added on 2025-10-03T03:51:06.510Z>",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement automated responsive design testing",
            "description": "Set up Playwright tests for responsive design validation",
            "dependencies": [
              "17.6"
            ],
            "details": "Create Playwright test suite that automatically tests responsive breakpoints across multiple components. Include tests for mobile navigation functionality, touch target sizes, layout integrity, and video player mobile controls.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-03T08:12:34.064Z"
          },
          {
            "id": 8,
            "title": "Performance optimization for mobile devices",
            "description": "Optimize loading performance and user experience on mobile networks",
            "dependencies": [
              "17.6"
            ],
            "details": "Implement mobile-specific performance optimizations including image optimization with responsive images, lazy loading for mobile, reduced JavaScript bundle sizes, and efficient CSS delivery. Test performance on slower mobile networks and optimize accordingly.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-03T08:14:48.238Z"
          }
        ],
        "updatedAt": "2025-10-03T08:14:49.202Z"
      },
      {
        "id": 18,
        "title": "WCAG 2.1 AA accessibility compliance",
        "description": "Implement complete accessibility compliance including screen reader support, keyboard navigation, and color contrast fixes",
        "details": "Audit all components for 4.5:1 color contrast ratio using contrast checker tools, implement ARIA labels on interactive elements, add keyboard navigation support with proper focus management, implement skip navigation links, add live regions for dynamic content with aria-live, test with screen readers (NVDA, JAWS, VoiceOver), and implement focus trap for modals using @headlessui/react or similar.",
        "testStrategy": "Automated accessibility testing with axe-core, manual screen reader testing, keyboard navigation testing, color contrast verification, and user testing with accessibility tools",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit and fix color contrast ratios",
            "description": "Use contrast checker tools to audit all components for 4.5:1 color contrast ratio compliance and fix violations",
            "dependencies": [],
            "details": "Systematically audit all UI components using automated tools like axe-core and manual contrast checkers. Identify all color combinations that fail WCAG 2.1 AA standards (4.5:1 ratio for normal text, 3:1 for large text). Update CSS variables and Tailwind classes to ensure compliant color combinations across buttons, links, text, backgrounds, and interactive elements.\n<info added on 2025-10-03T08:28:54.856Z>\nI'll analyze the codebase to understand the current accessibility implementation and then provide an update for the subtask based on the completion of the color contrast audit work.Based on my analysis of the codebase, I can see that a comprehensive color contrast audit has been completed for WCAG 2.1 AA compliance. Here's the new information that should be appended to the subtask's details:\n\nCOMPLETED: Color contrast audit successfully finished with 85% WCAG 2.1 AA compliance achieved. Created comprehensive audit documentation at .taskmaster/docs/accessibility-color-contrast-audit.md detailing all color combinations analysis. Critical disabled state opacity issue fixed across all form components (button.tsx, input.tsx, textarea.tsx, checkbox.tsx, select.tsx, radio-group.tsx) by replacing opacity-based styling with explicit color values ensuring 3:1 contrast ratio compliance. Installed @axe-core/playwright v4.10.2 for automated accessibility testing. Built complete test suite at tests/e2e/accessibility/color-contrast.spec.ts with 11 comprehensive test cases covering homepage, courses, dashboard, buttons, form inputs, disabled states, focus indicators, links, navigation, badges, and dark mode scenarios. Added test:accessibility script to package.json for dedicated accessibility testing. Platform achieves 85% compliance with remaining work needed for hover state verification, accent badge colors, and destructive button colors. All primary text (20.5:1), secondary text (15.8:1), button colors (5.8:1-7.1:1), and focus indicators fully compliant.\n</info added on 2025-10-03T08:28:54.856Z>",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-03T08:29:32.973Z"
          },
          {
            "id": 2,
            "title": "Implement ARIA labels on interactive elements",
            "description": "Add comprehensive ARIA labels, descriptions, and roles to all interactive UI components",
            "dependencies": [],
            "details": "Add proper ARIA attributes to all interactive elements including buttons, form controls, navigation menus, modals, and custom components. Implement aria-label, aria-describedby, aria-expanded, aria-hidden, and role attributes. Ensure all interactive elements have accessible names and descriptions for screen readers.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-03T08:33:00.615Z"
          },
          {
            "id": 3,
            "title": "Add keyboard navigation support with focus management",
            "description": "Implement comprehensive keyboard navigation with proper focus management and visible focus indicators",
            "dependencies": [
              "18.2"
            ],
            "details": "Implement keyboard navigation for all interactive elements using Tab, Enter, Space, and arrow keys. Add visible focus indicators that meet contrast requirements. Implement logical tab order with proper tabindex management. Add custom keyboard handlers for complex components like video players, course navigation, and dashboard interfaces.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement skip navigation links",
            "description": "Add skip navigation links to bypass repetitive content and improve keyboard navigation efficiency",
            "dependencies": [
              "18.3"
            ],
            "details": "Create skip links at the beginning of each page that allow keyboard users to jump to main content, navigation menus, and other key sections. Implement visually hidden skip links that become visible on focus. Add skip links for course content, video players, and multi-step forms.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-03T08:35:30.351Z"
          },
          {
            "id": 5,
            "title": "Add live regions for dynamic content",
            "description": "Implement ARIA live regions to announce dynamic content changes to screen readers",
            "dependencies": [
              "18.2"
            ],
            "details": "Add aria-live regions for dynamic content updates including form validation messages, loading states, progress indicators, notification toasts, and real-time updates. Implement polite and assertive announcements based on content urgency. Ensure screen readers announce video progress, course completion, and payment status changes.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-03T08:35:29.768Z"
          },
          {
            "id": 6,
            "title": "Test with screen readers",
            "description": "Comprehensive testing with NVDA, JAWS, and VoiceOver screen readers across all major user flows",
            "dependencies": [
              "18.1",
              "18.2",
              "18.3",
              "18.4",
              "18.5"
            ],
            "details": "Test all critical user journeys with multiple screen readers including course browsing, enrollment, video playback, quiz taking, and payment flows. Document screen reader behavior and fix any issues with content announcement, navigation, or interaction. Test on Windows (NVDA, JAWS), macOS (VoiceOver), and mobile devices.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement focus trap for modals",
            "description": "Add focus trapping to modals and dialogs using @headlessui/react or similar solution",
            "dependencies": [
              "18.3"
            ],
            "details": "Implement focus trapping for all modal dialogs, popover menus, and overlay components. Ensure focus moves to the modal when opened, stays within the modal during navigation, and returns to the triggering element when closed. Use @headlessui/react Dialog component or similar accessible solution with proper escape key handling.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Automated accessibility testing integration",
            "description": "Set up automated accessibility testing with axe-core and integrate into CI/CD pipeline",
            "dependencies": [
              "18.6",
              "18.7"
            ],
            "details": "Integrate axe-core automated testing into the Jest test suite and Playwright E2E tests. Create accessibility test utilities and helper functions. Set up CI/CD pipeline checks to prevent accessibility regressions. Generate accessibility reports and establish baseline scores for ongoing monitoring.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-03T08:35:30.351Z"
      },
      {
        "id": 19,
        "title": "Enhanced course discovery with filtering and search",
        "description": "Implement advanced filtering, search with autocomplete, and course recommendation system",
        "details": "Build search functionality using Fuse.js or Algolia for fuzzy search, implement filter UI with checkboxes for category, level, price range, and rating, create autocomplete component with debounced search queries, implement course recommendation algorithm based on user enrollment history and preferences, add 'Featured' and 'Trending' sections using course analytics data, and create wishlist functionality with localStorage/database persistence.",
        "testStrategy": "Search relevance testing, filter combination testing, performance testing with large course datasets, user experience testing for search flows, and A/B testing for recommendation accuracy",
        "priority": "high",
        "dependencies": [
          "14"
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Video processing pipeline implementation",
        "description": "Create video transcoding pipeline for multiple qualities, thumbnail generation, and metadata extraction",
        "details": "Implement video transcoding using FFmpeg.js or cloud service (AWS MediaConvert, Cloudinary), create job queue using Bull/Agenda for background processing, generate video thumbnails using canvas or video frame extraction, implement video validation for format/size/duration limits, add video storage integration with AWS S3 or Cloudinary, create progress tracking for transcoding jobs, and implement adaptive bitrate streaming manifests (HLS/DASH).",
        "testStrategy": "Video processing quality tests, transcoding performance benchmarks, storage integration tests, job queue reliability tests, and end-to-end video upload-to-playback testing",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement video transcoding",
            "description": "Set up video transcoding service using FFmpeg.js or a cloud provider for multiple quality renditions.",
            "dependencies": [],
            "details": "Configure FFmpeg.js in Node.js or provision AWS MediaConvert/Cloudinary jobs. Define input/output settings, create quality presets, and implement fallback logic between local and cloud transcoding.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create background job queue",
            "description": "Implement a job queue for processing video transcoding tasks asynchronously.",
            "dependencies": [
              "20.1"
            ],
            "details": "Install and configure Bull or Agenda with Redis. Define producers to enqueue transcoding tasks and processors to execute them, handling concurrency, retries, and scaling.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Generate video thumbnails",
            "description": "Extract and generate thumbnails from video frames at specified intervals.",
            "dependencies": [
              "20.2"
            ],
            "details": "Use HTML5 canvas or ffmpeg frame extraction in Node.js to capture frames at defined timestamps. Produce multiple resolution thumbnails and store timestamp metadata.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement video validation",
            "description": "Validate video files for format, size, and duration limits before processing.",
            "dependencies": [
              "20.3"
            ],
            "details": "Enforce allowed file formats (e.g., MP4, MOV), maximum file size, and duration thresholds. Perform validation checks prior to enqueueing jobs and reject invalid uploads.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Integrate video storage",
            "description": "Add integration with AWS S3 or Cloudinary for storing transcoded videos and thumbnails.",
            "dependencies": [
              "20.4"
            ],
            "details": "Configure AWS S3 buckets or Cloudinary accounts, manage credentials and ACLs, and implement upload/download logic. Include lifecycle policies and cleanup of obsolete assets.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement progress tracking",
            "description": "Track and report the progress of transcoding jobs in real time.",
            "dependencies": [
              "20.5"
            ],
            "details": "Capture transcoding progress metrics (percentage complete) and persist to a database or in-memory store. Expose a REST/WebSocket endpoint for clients to fetch live updates.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Generate adaptive streaming manifests",
            "description": "Create HLS and DASH manifests for adaptive bitrate streaming.",
            "dependencies": [
              "20.6"
            ],
            "details": "Use ffmpeg or cloud service APIs to segment video files and produce .m3u8 (HLS) and .mpd (DASH) manifests. Ensure correct segment indexing and map quality renditions.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Add error handling and retry logic",
            "description": "Implement robust error handling and automatic retry policies for the pipeline.",
            "dependencies": [
              "20.7"
            ],
            "details": "Centralize error capture in job processors, configure retry strategies in Bull/Agenda, log failures, and send notifications for repeated errors or critical issues.",
            "status": "done",
            "testStrategy": ""
          }
        ],
        "updatedAt": "2025-10-05T05:04:59.766Z"
      },
      {
        "id": 21,
        "title": "Comprehensive test suite expansion",
        "description": "Achieve 80% code coverage with unit, integration, and E2E tests for all critical user journeys",
        "details": "Expand existing test files in src/__tests__ to cover all utility functions, API routes, and components. Write integration tests for payment flows, course enrollment, video streaming, and instructor workflows. Create E2E tests using existing Playwright setup for complete user journeys. Implement visual regression testing with Percy or similar, add performance testing for video streaming and API endpoints, and create load testing scenarios for concurrent users.",
        "testStrategy": "Code coverage reporting with Jest, CI/CD integration for automated testing, performance benchmarking, test data management, and test environment isolation",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Expand unit test coverage for utilities and API routes",
            "description": "Add comprehensive unit tests for all utility functions, API route handlers, and core business logic to achieve baseline coverage",
            "dependencies": [],
            "details": "Write unit tests for all functions in src/lib/, src/hooks/, and src/app/api/ directories. Focus on payment processing utilities, video streaming logic, authentication helpers, validation schemas, and database operations. Set up Jest coverage reporting and aim for 80% coverage on utility functions.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create integration tests for payment and enrollment flows",
            "description": "Build comprehensive integration tests covering payment processing, course enrollment, and license key activation workflows",
            "dependencies": [
              "21.1"
            ],
            "details": "Test complete payment flows using Dodo Payments MCP integration, course enrollment with license key generation, webhook processing for payment events, database state changes, and error handling scenarios. Include both successful and failure cases.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Expand E2E tests for critical user journeys",
            "description": "Use existing Playwright setup to create comprehensive end-to-end tests for all major user workflows",
            "dependencies": [
              "21.1"
            ],
            "details": "Build E2E tests for user registration/authentication, course discovery and enrollment, video streaming and lesson completion, instructor course creation, payment processing, and progress tracking. Test across different user roles (Student, Instructor, Admin).",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement visual regression testing",
            "description": "Set up visual regression testing to catch UI changes and ensure consistent user interface across releases",
            "dependencies": [
              "21.3"
            ],
            "details": "Integrate Percy or similar visual testing tool with existing Playwright setup. Create baseline screenshots for all major pages and components. Configure visual diff thresholds and set up automated visual testing in CI/CD pipeline.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add performance testing for video streaming",
            "description": "Create performance tests for video streaming endpoints and adaptive quality selection functionality",
            "dependencies": [
              "21.2"
            ],
            "details": "Build performance tests for /api/video/stream endpoint, test video quality adaptation under different network conditions, measure session heartbeat performance, test concurrent video streaming sessions, and validate video analytics tracking performance.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create load testing scenarios for concurrent users",
            "description": "Develop load testing scenarios to validate platform performance under high concurrent user loads",
            "dependencies": [
              "21.5"
            ],
            "details": "Use tools like Artillery or k6 to create load testing scenarios for API endpoints, database operations, authentication flows, and video streaming. Test scenarios include peak enrollment periods, concurrent video streaming, and high-traffic course launches.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Set up CI/CD integration for automated testing",
            "description": "Integrate all test suites into CI/CD pipeline with coverage reporting and automated quality gates",
            "dependencies": [
              "21.4",
              "21.6"
            ],
            "details": "Configure GitHub Actions or similar CI/CD to run full test suite on pull requests, set up coverage reporting with threshold enforcement (80%), integrate visual regression testing, add performance monitoring alerts, and create test result dashboards.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-03T16:29:53.686Z"
      },
      {
        "id": 22,
        "title": "Redis caching implementation",
        "description": "Implement Redis caching for expensive queries and user sessions with cache invalidation strategies",
        "details": "Integrate Redis using existing REDIS_URL configuration and ioredis client. Cache course catalog data with TTL of 1 hour, user enrollment status with 30-minute TTL, video metadata with 24-hour TTL, and user session data. Implement cache invalidation on course updates, enrollment changes, and user modifications. Add cache warming strategies for popular courses and cache hit/miss monitoring with metrics.",
        "testStrategy": "Cache hit/miss ratio testing, cache invalidation verification, performance comparison with/without caching, memory usage monitoring, and cache coherence testing",
        "priority": "medium",
        "dependencies": [
          "14"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up ioredis client, key conventions, and cache helpers",
            "description": "Initialize Redis via ioredis using REDIS_URL and provide reusable cache utilities.",
            "dependencies": [],
            "details": "Create a Redis client (ioredis) using REDIS_URL with retryStrategy, maxRetriesPerRequest, enableAutoPipelining, and TLS if rediss. Implement cache helpers: cacheGet<T>(key), cacheSet(key, value, ttlSec), cacheDel(keys|pattern), cacheMGet, cacheMSet with JSON serialization and optional compression. Define key namespaces/prefix: app:cache:{env}: (course:catalog, enroll:{userId}:{courseId}, video:meta:{videoId}, session:{sid}). Provide a TTL map: courseCatalog=3600s, enrollment=1800s, videoMeta=86400s, session=per-session-config. Add healthcheck (PING/latency), graceful shutdown (quit on SIGTERM), and metrics hooks (hit/miss/error counters, latency histogram).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Cache course catalog data with TTL and warming",
            "description": "Wrap expensive course catalog queries with Redis caching and add warming for popular catalogs.",
            "dependencies": [
              "22.1"
            ],
            "details": "Implement a catalog fetch wrapper: build deterministic cache keys from query params/filters (e.g., app:cache:{env}:course:catalog:v1:{hashOfParams}), check cache first, on miss fetch DB and set TTL=3600s. Add optional stale-while-revalidate: serve cached data if fresh, refresh in background near expiry. Implement a warming job (cron or queue) to prefill popular catalogs/top N categories on startup and hourly. Emit hit/miss metrics and log payload sizes to monitor memory usage.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Cache user enrollment status, video metadata, and sessions",
            "description": "Add caching for user enrollment checks, video metadata, and Redis-backed user sessions.",
            "dependencies": [
              "22.1"
            ],
            "details": "Enrollment: key app:cache:{env}:enroll:v1:u:{userId}:c:{courseId}, TTL=1800s; provide batched getters for course lists via MGET. Video metadata: key app:cache:{env}:video:meta:v1:{videoId}, TTL=86400s; prime after metadata extraction and on first access. Sessions: integrate Redis session store (e.g., connect-redis/next-auth adapter), prefix app:cache:{env}:session:, rolling/touch behavior, TTL from session config, secure cookie settings, logout/session-destroy handling. Track per-scope metrics (hits/misses/errors) and latency.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement cache invalidation, pub/sub fanout, and monitoring",
            "description": "Wire invalidation on domain events and add metrics dashboards for cache performance.",
            "dependencies": [
              "22.1",
              "22.2",
              "22.3"
            ],
            "details": "Invalidate on course updates (delete catalog keys impacted and related video:meta for course), enrollment changes (delete enroll keys for user/course), and user modifications (delete user sessions and related user-scoped caches). Implement a pub/sub channel (cache:invalidate) so all instances receive invalidation events and delete keys; ensure idempotent handlers and pattern deletes via SCAN. Add hit/miss ratio, errors, and latency metrics (e.g., Prometheus), memory usage tracking, and alerts for low hit rate/high memory. Provide basic integration tests to verify hit/miss behavior, invalidation propagation, and performance improvements.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 23,
        "title": "Database seeding with comprehensive sample data",
        "description": "Create extensive seed data including 20+ courses, instructors, students, and enrollment data for testing",
        "details": "Extend existing prisma/seed.ts and seed-course.ts files to create realistic sample data: 20+ courses across different categories, 5+ instructor profiles with complete details, 50+ student accounts with varied enrollment history, sample progress and completion data, payment and license records, forum posts and discussions, quiz attempts and results. Implement seed data for different environments (development, staging) and create data reset/refresh scripts.",
        "testStrategy": "Seed data integrity validation, database constraint verification, performance testing with seeded data, data consistency checks, and environment-specific seeding verification",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend course seed data to 20+ comprehensive courses",
            "description": "Expand existing seed-course.ts to create 20+ realistic courses across Unity, Unreal Engine, Godot, and other game development categories with complete course structures",
            "dependencies": [],
            "details": "Modify existing seed-course.ts file to generate diverse courses including: beginner to advanced Unity courses (2D/3D game development, UI systems, physics), Unreal Engine courses (blueprints, C++, materials, lighting), Godot courses (GDScript, 2D/3D development), specialized topics (VR development, mobile games, indie game marketing). Each course should have realistic titles, descriptions, pricing, difficulty levels, estimated duration, and proper category assignment.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create comprehensive instructor and student profiles",
            "description": "Generate 5+ detailed instructor profiles and 50+ student accounts with realistic personal information and varied backgrounds",
            "dependencies": [],
            "details": "Create instructor seed data with complete profiles including bio, expertise areas, social links, profile images, teaching experience, and specializations. Generate 50+ student accounts with varied demographics, learning preferences, skill levels, and enrollment histories. Include realistic names, email addresses, profile pictures, join dates, and activity patterns to simulate a diverse user base.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Generate enrollment history and progress tracking data",
            "description": "Create realistic enrollment patterns, course progress, lesson completions, and learning analytics for all seeded users",
            "dependencies": [
              "23.1",
              "23.2"
            ],
            "details": "Generate enrollment records linking students to courses with realistic enrollment dates and patterns. Create progress tracking data showing varied completion rates, lesson view history, quiz attempts and scores, time spent on lessons, and course completion certificates. Include dropped courses, active learning paths, and seasonal enrollment patterns to simulate real user behavior.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create payment records and license key data",
            "description": "Generate sample payment transactions, license keys, and financial records for testing payment flows and course access",
            "dependencies": [
              "23.3"
            ],
            "details": "Create payment records with various payment methods (credit card, PayPal, etc.), payment statuses (completed, pending, failed, refunded), and transaction amounts. Generate corresponding license keys for successful payments, including activation dates, expiry dates, and usage limits. Include sample subscription data, discount codes, and promotional pricing to test all payment scenarios.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement environment-specific seeding and data management scripts",
            "description": "Create scripts for different environments (development, staging) and data reset/refresh functionality",
            "dependencies": [
              "23.1",
              "23.2",
              "23.3",
              "23.4"
            ],
            "details": "Develop environment-specific seed configurations in prisma/seed.ts with different data volumes for development (smaller dataset) and staging (full dataset). Create npm scripts for data reset, refresh, and selective seeding. Implement database cleanup utilities, data export/import functionality, and seed data validation checks. Add error handling and rollback mechanisms for failed seeding operations.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-04T02:45:06.588Z"
      },
      {
        "id": 24,
        "title": "Email system integration",
        "description": "Implement email service with templates for welcome, enrollment, payment receipts, and notifications",
        "details": "Integrate email service using SendGrid or Resend APIs with existing environment configuration. Create email templates using React Email or similar for welcome emails, course enrollment confirmation, payment receipts, license key delivery, progress milestones, and certificate delivery. Implement email queue using Bull for reliability, add email tracking and analytics, create email preference management system, and implement transactional email logging.",
        "testStrategy": "Email delivery testing, template rendering verification, queue processing tests, email tracking validation, and spam filter testing",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Provider integration, domain authentication, and configuration",
            "description": "Integrate a provider-agnostic email adapter supporting SendGrid or Resend with secure environment configuration and domain authentication.",
            "dependencies": [],
            "details": "Set up provider-agnostic email adapter with support for SendGrid or Resend. Implement interface sendEmail({ to, from, subject, html, text, headers, categories, customArgs }) and provider-specific implementations. Configure environment variables (RESEND_API_KEY or SENDGRID_API_KEY, MAIL_FROM, MAIL_REPLY_TO), secrets in CI/CD, and runtime config toggling provider. Complete domain authentication (SPF, DKIM, DMARC), link branding, and bounce domain. Add health check endpoint and dry-run mode. Document DNS records and verification steps.",
            "status": "pending",
            "testStrategy": "Verify DNS: SPF/DKIM/DMARC pass (using mail-tester or Gmail headers). Send test emails via sandbox and live mode. Unit-test adapter with mocked HTTP clients. Integration test that provider selection fallback works if primary fails. Validate from/reply-to and return-path. Run basic spam score checks."
          },
          {
            "id": 2,
            "title": "Template system and catalog using React Email",
            "description": "Build a reusable React Email template system and implement all required transactional templates.",
            "dependencies": [],
            "details": "Create React Email based template system with a shared BaseLayout, theme, and partials (header, footer, button). Implement templates: Welcome, Enrollment Confirmation, Payment Receipt (itemized, taxes), License Key Delivery, Progress Milestone, Certificate Delivery. Support plain-text variants, localization, preheaders, and dark mode. Implement a local preview server and HTML/CSS inlining. Define TypeScript types for each template's data payload and a template registry mapping template keys to components and default subjects.",
            "status": "pending",
            "testStrategy": "Snapshot test rendered HTML and text for each template with sample payloads. Visual regression via Storybook or React Email preview. Validate responsiveness at common widths. Accessibility checks (semantic tags, contrast). Ensure all dynamic placeholders render and gracefully handle missing optional fields."
          },
          {
            "id": 3,
            "title": "Email queue and delivery pipeline with BullMQ",
            "description": "Implement a reliable email queuing and processing pipeline using BullMQ and Redis with retries, idempotency, and scheduling.",
            "dependencies": [
              "24.1",
              "24.2"
            ],
            "details": "Implement BullMQ-based email queue backed by Redis. Define job schema {recipient, templateKey, payload, category, correlationId, dedupeKey}. Add rate limiting, exponential backoff, retries, dead-letter queue, and concurrency controls. Enforce idempotency with dedupeKey and provider messageId storage. Processor composes template using the registry, performs preference gating hook, and calls the provider adapter. Provide metrics and structured logs, and enable delayed scheduling (e.g., milestone reminders). Containerize a separate worker process with graceful shutdown.",
            "status": "pending",
            "testStrategy": "Unit-test job processor happy path and failure modes (template error, provider 429/500). Integration tests with Redis to verify retry/backoff and DLQ. Concurrency and rate-limit tests. Ensure deduplication prevents duplicates under concurrent enqueue. Verify delayed jobs fire at expected times and survive restarts."
          },
          {
            "id": 4,
            "title": "Tracking, webhook ingestion, analytics, and transactional logging",
            "description": "Implement event tracking via provider webhooks, store logs and events, and build analytics for deliverability and engagement.",
            "dependencies": [
              "24.1",
              "24.3"
            ],
            "details": "Implement webhook ingestion and analytics. Expose /api/webhooks/email to receive provider events (processed, delivered, open, click, bounce, spamreport, unsubscribe). Verify signatures (SendGrid signed payload, Resend HMAC). Persist to email_messages (message metadata) and email_events (time-series events) tables. Update message status and maintain suppression lists on bounce/complaint. Build lightweight analytics queries (deliverability, open/click rates by template). Add open tracking pixel and click redirector if provider tracking is disabled. Implement transactional email logging with correlationId and providerMessageId.",
            "status": "pending",
            "testStrategy": "Replay provider sample payloads and assert signature validation, idempotent upserts, and status transitions. E2E: send email, receive webhook, ensure logs and analytics updated. Test suppression on hard bounce blocks future sends. Verify privacy controls and data retention windows."
          },
          {
            "id": 5,
            "title": "Email preference management and compliance",
            "description": "Build preference center, unsubscribe flows, and compliance features; enforce preferences in the send pipeline.",
            "dependencies": [
              "24.2",
              "24.3",
              "24.4"
            ],
            "details": "Implement email preference management and compliance. Design DB schema for email_preferences with per-user per-category status. Define categories mapping for each template: transactional.enrollment, transactional.billing, transactional.progress, transactional.certificate, transactional.general (always-on), product.updates. Build public preference center UI and API with signed tokens (List-Unsubscribe and List-Unsubscribe-Post headers) and one-click unsubscribe. Integrate preference checks in the queue gating hook before enqueue/send, honoring suppression lists. Add audit logging, double opt-in for marketing, and i18n. Ensure CAN-SPAM/GDPR/CCPA compliance.",
            "status": "pending",
            "testStrategy": "Unit tests for preference evaluation and token signature validation. Integration tests to ensure unsubscribed users do not receive non-essential emails while transactional.general still sends. Verify List-Unsubscribe headers present and functional. E2E flow for marketing double opt-in. Pen-test unsubscribe links for tampering."
          }
        ]
      },
      {
        "id": 25,
        "title": "Course player immersive experience",
        "description": "Create immersive course player with lesson sidebar, notes, Q&A, and autoplay functionality",
        "details": "Build immersive course player layout extending existing lesson pages with lesson sidebar showing progress indicators, course notes/bookmarks functionality using localStorage and database sync, Q&A section per lesson with threaded discussions, resource downloads section, next lesson autoplay with countdown timer, keyboard shortcuts guide modal, and lesson completion tracking with automatic progress updates.",
        "testStrategy": "User experience testing for player interface, progress tracking accuracy tests, note-taking functionality tests, discussion feature tests, and cross-browser player compatibility",
        "priority": "high",
        "dependencies": [
          "12"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Build immersive course player layout and lesson sidebar",
            "description": "Create responsive player layout extending lesson pages with a collapsible lesson sidebar and visual progress indicators.",
            "dependencies": [],
            "details": "• Implement PlayerLayout shell with header, video area, right/left side panels, and responsive breakpoints (desktop sidebar, mobile drawer).\n• Build LessonSidebar component: module/lesson tree, completion checkmarks, overall course progress bar, current lesson highlight, hover tooltips.\n• Integrate routing (/courses/:courseId/lessons/:lessonId) and data fetching for course structure and user progress; include loading skeletons and error states.\n• Add sticky behavior, keyboard focus order, and ARIA roles for accessibility; support virtualized lists for large courses.\n• Expose slots/regions for Notes, Q&A, Resources panels; persist sidebar open/closed state in localStorage.\n<info added on 2025-10-05T05:55:02.959Z>\nDelivered production-ready CoursePlayerLayout and LessonSidebar implementations covering responsive shell, sticky header with autoplay preferences, keyboard shortcuts, and persistent sidebar state, plus module navigation with progress tracking, auto-scroll/highlighting, and lesson type badges. Routing for /courses/:courseId/lessons/:lessonId now wired with data fetching, skeletons, and error handling, completing the immersive layout subtask.\n</info added on 2025-10-05T05:55:02.959Z>",
            "status": "in-progress",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement notes and bookmarks with localStorage and DB sync",
            "description": "Enable per-lesson notes and timestamped bookmarks with offline support and server synchronization.",
            "dependencies": [
              "25.1"
            ],
            "details": "• UI: Notes panel with add/edit/delete, rich text or markdown, timestamp insertion from current video time, filter/search notes.\n• Bookmarks: timeline markers on the seek bar; list view with jump-to-time capability and labels.\n• Storage: autosave notes/bookmarks to localStorage (debounced) and sync to DB via API; optimistic updates; conflict resolution with last-write-wins and field-level merge when possible.\n• Schema: LessonNote(userId, lessonId, timecode?, content), LessonBookmark(userId, lessonId, timecode, label, color?).\n• Permissions: user-private notes; export/import notes as JSON; handle offline mode and retry queue.\n• Telemetry: track note created, bookmark added, note edited/deleted events.\n<info added on 2025-10-05T05:55:29.309Z>\nImplementation plan defines Prisma LessonNote (id, userId, lessonId, timecode Int?, content Json, updatedAt, createdAt) and LessonBookmark (id, userId, lessonId, timecode Int, label String, color String?, updatedAt, createdAt) models with relations to Lesson and User. API surface exposes REST endpoints at /api/lessons/[lessonId]/notes and /api/lessons/[lessonId]/bookmarks supporting GET for list retrieval, POST for optimistic create, PATCH for partial updates, and DELETE by id, returning shape { id, timecode, content, label, color, updatedAt }. NotesPanel React component wraps TipTap editor with toolbar, note list, timestamp insertion from current video time, search/filter inputs, and state machines for optimistic status. BookmarkControls integrate with the video seek bar to render markers and allow click-to-seek via useVideoPlayerContext. Client data layer stores drafts in localStorage keyed by user and lesson, debounces sync with mutateNote/mutateBookmark hooks, reconciles conflicts with last-write-wins and field-level merge for content blocks. Export/import flows serialize notes and bookmarks to JSON with schema validation, download/upload helpers, and import warnings on duplicates. Telemetry hooks dispatch analytics events for note created/edited/deleted and bookmark added/removed, with retry queue support for offline mode.\n</info added on 2025-10-05T05:55:29.309Z>\n<info added on 2025-10-05T06:06:06.796Z>\nImplementation analysis confirms existing VideoBookmark (with note field) and VideoProgress models; schema requires new LessonNote model with id (cuid), rich text content string, optional timecode, timestamps, relations to User and Lesson with cascade delete, and indexes on userId+lessonId and createdAt. Documented REST endpoints: POST and GET /api/lessons/[lessonId]/notes, PATCH /api/lessons/[lessonId]/notes/[noteId], DELETE /api/lessons/[lessonId]/notes/[noteId], POST and GET /api/lessons/[lessonId]/bookmarks, DELETE /api/lessons/[lessonId]/bookmarks/[bookmarkId]. Planned React assets include NotesPanel.tsx leveraging TipTap, BookmarksPanel.tsx for timeline markers, useNotes.ts for localStorage plus API sync, and useBookmarks.ts for optimistic updates. Client sync strategy defines localStorage key lesson_notes_${userId}_${lessonId}, a two-second debounce after edits, last-write-wins conflict handling, and JSON export/import with schema versioning. Implementation deferred until disk capacity issue (current storage full) is resolved; blueprints ready for immediate deployment once space is available.\n</info added on 2025-10-05T06:06:06.796Z>",
            "status": "in-progress",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add Q&A section with threaded discussions",
            "description": "Provide per-lesson Q&A with threads, replies, moderation, and real-time updates.",
            "dependencies": [
              "25.1"
            ],
            "details": "• UI: Q&A panel with create question, threaded replies, markdown editor, code blocks, attachments, and instructor badges.\n• Features: upvote, accept/resolve answer, pin by instructor, sort by newest/top/resolved, pagination or infinite scroll.\n• Backend: endpoints for CRUD on questions/replies, voting, resolve/pin; rate limiting and spam protection.\n• Realtime: live updates via WebSocket/SSE (fallback to polling); optimistic posting.\n• Moderation: report/flag flow, soft delete, audit logs; permission checks (enrolled users only).\n• Notifications: subscribe to thread, in-app toasts for replies; deep-link to specific posts.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create resource downloads section",
            "description": "List and manage per-lesson downloadable resources with access controls and tracking.",
            "dependencies": [
              "25.1"
            ],
            "details": "• UI: Resources panel listing files/links with type icons, sizes, last updated, and per-item descriptions.\n• Functionality: secure download URLs, support external links, checksum display for large files, bulk download where applicable.\n• Access: enforce enrollment/entitlements; handle expired links and error states; show license/usage notes.\n• Tracking: log download events, prevent duplicate counters via debounce; display per-lesson resource count in sidebar.\n• Performance: prefetch resource metadata; resume support for large files where supported.\n• Admin metadata surfaced from existing lesson attachments; fallback when none available.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement next-lesson autoplay with countdown",
            "description": "Auto-advance to the next lesson with a configurable countdown overlay and user controls.",
            "dependencies": [
              "25.1"
            ],
            "details": "• Trigger on video end (or completion threshold) to show overlay with next lesson title/thumbnail and countdown (default 8s).\n• Controls: cancel, play now, previous lesson; global autoplay toggle persisted per user; remember per-device in localStorage and sync to profile.\n• Prefetch next lesson metadata and prewarm route; handle last-lesson edge case with course-complete CTA.\n• Accessibility: focus management, screen reader announcements, keyboard shortcuts, and reduced-motion support.\n• Resilience: cancel autoplay if Q&A composer is open or user is interacting; pause on tab hidden if configured.\n• Analytics: capture autoplay shown, canceled, expedited, and completed events.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add keyboard shortcuts guide and progress tracking",
            "description": "Provide a shortcuts modal and implement automatic lesson completion/progress updates.",
            "dependencies": [
              "25.1",
              "25.5"
            ],
            "details": "• Shortcuts: '?' or Shift+/ opens modal; keys for play/pause, seek ±5/10s, speed ±, captions toggle, mute, fullscreen, toggle autoplay, open Notes/Q&A/Resources panels, mark complete, next/prev lesson.\n• Modal: searchable list, context-aware hints, and link to settings; ensure discoverability via UI icon.\n• Progress tracking: auto-mark complete at 90% watched (configurable) using video time updates and visibility checks; manual toggle with confirmation.\n• Sync: POST progress to server, update sidebar badges and overall course progress; cross-tab sync via storage events.\n• Edge cases: resume position on revisit, handle variable playback speeds, buffering gaps, and user seek behavior to prevent false positives.\n• QA: unit and E2E tests for events, persistence, and UI states; emit analytics for completion and shortcut usage.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 26,
        "title": "Quiz and assessment builder",
        "description": "Create comprehensive quiz builder with multiple question types, drag-and-drop reordering, and analytics",
        "details": "Extend existing quiz components in src/components/quiz/ to create quiz builder interface with question type selection (multiple choice, true/false, short answer, code challenges), drag-and-drop question reordering using @dnd-kit, answer validation rules, quiz settings (time limits, passing scores, retake policies), quiz preview functionality, question bank for reusability, and quiz analytics dashboard with performance metrics.",
        "testStrategy": "Quiz creation workflow testing, question type validation, drag-and-drop functionality tests, quiz taking simulation, analytics accuracy verification, and accessibility testing for quiz interfaces",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Instructor analytics dashboard",
        "description": "Create comprehensive analytics dashboard for instructors with course performance, revenue, and engagement metrics",
        "details": "Build instructor analytics dashboard extending existing instructor pages with course performance metrics (enrollments, completion rates), revenue analytics with charts using Recharts or similar, student engagement metrics (video watch time, quiz scores), video analytics (watch time, dropout points), export functionality for reports, date range filtering, real-time statistics, and comparative analysis across multiple courses.",
        "testStrategy": "Analytics data accuracy verification, chart rendering tests, export functionality validation, performance testing with large datasets, and user interface usability testing",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Build course performance metrics dashboard and shared analytics shell",
            "description": "Implement dashboard shell and course performance KPIs and charts (enrollments, completions, completion rate, active learners) with real-time stats and multi-course comparison.",
            "dependencies": [],
            "details": "Create shared layout/components on existing instructor pages (KPI cards, Recharts line/area charts, sortable tables); add course multi-select comparator and dashboard-level state; implement real-time updates via WebSocket/SSE (fallback polling) for new enrollments/completions; build backend aggregation endpoints with caching and access controls; include loading/error states and skeletons; prepare hooks/contexts for global filters (to be wired in 27.5); verify data accuracy against source tables and support large datasets with pagination/virtualization.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Add revenue analytics with Recharts",
            "description": "Build revenue analytics module showing gross/net revenue, refunds, ARPU, and per-course/channel breakdown with time-series and categorical charts.",
            "dependencies": [
              "27.1"
            ],
            "details": "Implement revenue aggregation endpoints (transactions, fees, refunds, taxes) with currency and timezone handling; compute metrics (gross, net, refunds rate, ARPU, AOV) and daily/weekly series; add Recharts stacked area/line for revenue over time and bar charts by course/channel; include top-earning courses table and recent transactions feed; support multi-course comparison via shared shell; add optional real-time ticker for new sales events; enforce permissions and data masking for sensitive fields.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement student engagement metrics",
            "description": "Provide engagement dashboards: aggregate video watch time, quiz scores, DAU/WAU/MAU, time-on-task, progression funnel, and engagement score per course and cohort.",
            "dependencies": [
              "27.1"
            ],
            "details": "Aggregate telemetry from video player and assessments; expose endpoints for retention curves, average quiz scores, attempts distribution, session duration, and cohort retention; visualize with Recharts histograms, bar/funnel approximations, and line charts; list low-engagement cohorts/modules and top improving courses; support multi-course comparison and cohort filters; ensure privacy (no PII by default) and performance via precomputed aggregates and caching.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create video analytics with watch time and dropout analysis",
            "description": "Deliver per-video analytics: watch time, average watch percentage, retention curves, heatmap/drop-off points, and playback issue events overview.",
            "dependencies": [
              "27.1"
            ],
            "details": "Precompute per-video retention bins (e.g., 0–100% in 5% steps) and watch-time aggregates; provide endpoints for per-video and per-course video summaries; visualize retention with Recharts line/area and bar charts for average watch %; surface top dropout timestamps and affected sessions; include table of videos with high dropout and completion correlation; support multi-course comparison; handle long videos via sampling/windowing; integrate with engagement metrics for drill-through.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add export functionality and global date range filtering",
            "description": "Implement global date range picker and apply across modules; add export of reports (CSV, PDF, JSON) with async processing for large datasets and comparative selections.",
            "dependencies": [
              "27.1",
              "27.2",
              "27.3",
              "27.4"
            ],
            "details": "Build reusable date picker with presets (7d, 30d, YTD, custom) and context wiring so all queries include range and course selections; validate ranges and timezones server-side; implement export services: CSV for tables, JSON for raw metrics, and PDF dashboard snapshots via headless renderer; use async job queue for heavy exports with notifications and secure download links; include column selection, anonymization toggle, and aggregation granularity options; ensure exports reflect current comparisons and freeze real-time data at export time; add audit logs, rate limiting, and e2e tests for filter propagation and export accuracy.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 28,
        "title": "Certificate system implementation",
        "description": "Design and implement certificate generation, verification system, and PDF downloads",
        "details": "Create certificate templates using HTML/CSS or PDF generation libraries, implement certificate generation on course completion using existing Certificate model, add certificate verification system with public URL and verification codes, create certificate gallery in user profiles, implement social sharing for certificates, add PDF download functionality using jsPDF or similar, certificate metadata management, and certificate revocation system for policy violations.",
        "testStrategy": "Certificate generation accuracy tests, PDF rendering verification, verification system security tests, social sharing functionality tests, and certificate template responsive design",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design certificate templates and metadata model",
            "description": "Create reusable HTML/CSS certificate templates and define required metadata fields and storage.",
            "dependencies": [],
            "details": "Build responsive, print-friendly HTML/CSS templates with placeholder variables (recipientName, courseTitle, completionDate, instructorName, certificateId, verificationUrl, qrCode, issuerSignature); add template storage (DB with versioning and active flags); define certificate metadata schema (issueDate, expiryDate optional, issuer, templateId, verificationCode, status, revocationReason, locale); implement template preview/editor and sanitization; ensure branding and localization support.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Automatic certificate issuance on course completion",
            "description": "Issue certificates using the existing Prisma Certificate model when learners complete a course.",
            "dependencies": [
              "28.1"
            ],
            "details": "Hook into course completion event/cron; generate unique immutable verification code (UUID + short hash), set issueDate, templateId, and metadata; create Certificate record idempotently; attach selected template per course; enqueue rendering/pre-compute artifacts placeholder; add audit logs and error handling; support backfill for already-completed learners.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Public verification and revocation system",
            "description": "Expose a public verification URL and API to validate certificates and manage revocations.",
            "dependencies": [
              "28.2"
            ],
            "details": "Create public route /certificates/:code for human-readable page and API endpoint returning status, owner (masked), course, issueDate, expiryDate, template version; display QR code linking to the verification URL; implement admin revocation with reason and timestamp, status transitions (active, revoked, expired); harden security with non-enumerable codes, rate limiting, and noindex; log verification attempts; show clear messaging for revoked/expired certificates.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "User profile certificate gallery",
            "description": "Add a gallery in user profiles to list, filter, and manage certificates with sharing controls.",
            "dependencies": [
              "28.2",
              "28.3"
            ],
            "details": "Build profile tab listing certificates with pagination, filters (course, status), and search; show thumbnail/preview, course, issue date, status; provide privacy controls (public/private), copy verification link, and visibility indicators for revoked/expired; include actions for view details and download; ensure accessibility and mobile responsiveness.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "PDF download and social sharing",
            "description": "Implement reliable PDF rendering and enable sharing to social platforms from certificate pages.",
            "dependencies": [
              "28.1",
              "28.2",
              "28.3"
            ],
            "details": "Implement PDF generation (server-side via Playwright/Puppeteer or client-side via jsPDF) with consistent A4 layout; add Download PDF endpoint with proper caching and content-disposition; embed verification URL and QR code in PDF; pre-render and cache PDFs on issuance where feasible; implement social share actions (LinkedIn, X/Twitter) using verification URL with correct Open Graph/Twitter Card metadata and preview image; ensure print support and file size constraints.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 29,
        "title": "CI/CD pipeline implementation",
        "description": "Create comprehensive CI/CD pipeline with automated testing, deployment checks, and rollback procedures",
        "details": "Implement GitHub Actions workflow for automated testing on pull requests, add deployment checks including tests, linting, and type checking, create staging environment deployment automation, implement database migration automation using Prisma, add deployment notifications via Slack/Discord, create rollback procedures for failed deployments, implement environment promotion workflows, and add deployment health checks.",
        "testStrategy": "CI/CD pipeline reliability testing, automated test execution verification, deployment rollback testing, staging environment validation, and deployment notification testing",
        "priority": "high",
        "dependencies": [
          "21"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up GitHub Actions workflow for automated testing",
            "description": "Create CI workflow to run tests automatically on pull requests and pushes",
            "dependencies": [],
            "details": "Deliverables:\n- .github/workflows/ci.yml with jobs for unit/integration tests\n- Triggers: pull_request to main and feature branches; push to main\n- Use actions/checkout@v4, actions/setup-node@v4 (Node 18/20 matrix), dependency caching\n- Commands: install deps, build if needed, run tests with coverage, upload artifacts (junit/coverage) if available\n- Optional: service container for DB if integration tests require it\n- Concurrency group to cancel in-progress runs for same ref\nAcceptance criteria:\n- Tests run automatically on PRs and main pushes\n- Failing tests mark PRs as failing",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Add deployment checks: tests, linting, and type checking",
            "description": "Expand CI to enforce lint, typecheck, and formatting checks alongside tests",
            "dependencies": [
              "29.1"
            ],
            "details": "Deliverables:\n- Extend ci.yml or add .github/workflows/checks.yml with jobs: test, lint (eslint), typecheck (tsc --noEmit), format check (prettier --check) as applicable\n- Problem matchers to annotate code issues in PRs\n- Set required status checks in branch protection rules for main\n- Fail build on any check failure\nAcceptance criteria:\n- PRs blocked until tests, lint, and typecheck pass\n- Check results visible in PR UI",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create staging environment deployment automation",
            "description": "Automate staging deploys after checks pass, with environment protections",
            "dependencies": [
              "29.2"
            ],
            "details": "Deliverables:\n- .github/workflows/deploy-staging.yml with jobs: build-artifact, deploy-staging\n- Trigger: push to main and workflow_dispatch; needs: checks from CI\n- Use environment: staging with required reviewers if needed; use concurrency group env-staging\n- Build once and upload artifact; deploy job downloads artifact and deploys via provider CLI/API (placeholder steps for Vercel/Netlify/AWS/K8s)\n- Store deployment metadata (version/commit) as outputs or artifact\n- Manual input to re-deploy a specific commit to staging\nAcceptance criteria:\n- Successful push to main deploys to staging automatically after checks pass\n- Ability to trace staging deployment to a commit/version",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement database migration automation with Prisma",
            "description": "Automate safe schema migrations during deployments using Prisma CLI",
            "dependencies": [
              "29.3"
            ],
            "details": "Deliverables:\n- Add migration step to deploy-staging and future prod workflows: prisma generate, prisma migrate deploy\n- Use DATABASE_URL from GitHub Encrypted Secrets; protect logs from leaking secrets\n- Pre-migration backup step or snapshot command (provider-specific placeholder)\n- Migration status reporting and failure handling to abort deploy on error\n- Guidelines: prefer backward-compatible (expand/contract) migrations; seed only in staging\nAcceptance criteria:\n- Migrations run automatically during staging deploys and fail-fast on errors\n- Clear logs for applied migrations and status",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add deployment notifications via Slack/Discord",
            "description": "Send CI and deployment notifications to Slack/Discord channels",
            "dependencies": [
              "29.3"
            ],
            "details": "Deliverables:\n- Notification step(s) in CI and deploy workflows for success/failure\n- Integrate Slack/Discord via incoming webhooks or official actions; secrets: SLACK_WEBHOOK_URL, DISCORD_WEBHOOK_URL\n- Message payload includes repo, environment, commit SHA, author, run URL, status, and duration\n- Rate-limit and deduplicate notifications on retried jobs\nAcceptance criteria:\n- Team receives notifications on CI failures and staging deploy outcomes\n- Messages contain actionable links and context",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create rollback procedures for failed deployments",
            "description": "Provide automated rollback workflow and integrate with deploy failure handling",
            "dependencies": [
              "29.3",
              "29.4"
            ],
            "details": "Deliverables:\n- .github/workflows/rollback.yml with workflow_dispatch inputs: environment (staging/prod), target version/commit\n- Steps to list recent deployments and redeploy previous stable artifact/image/version via provider CLI/API\n- Auto-invoke rollback on deployment failure hooks where safe; ensure idempotency and audit logs\n- Database guidance: application rollback is automated; DB rollback is manual unless reversible migrations exist; document playbook\nAcceptance criteria:\n- One-click/manual rollback to last known-good version\n- Failed deploys can trigger automatic rollback of application layer",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Add deployment health checks and promotion gating",
            "description": "Implement post-deploy health checks and gate production promotion on passing checks",
            "dependencies": [
              "29.3",
              "29.6"
            ],
            "details": "Deliverables:\n- App-level /healthz and /readyz endpoints; readiness includes DB connectivity\n- Post-deploy health-check job: poll health endpoint with backoff until success or timeout; capture logs on failure\n- On health-check failure, auto-trigger rollback workflow and notify Slack/Discord\n- Promotion workflow: promote-to-prod job reuses staging artifact after staging health checks pass; environment: production with required reviewers\n- Configurable SLOs (latency threshold, HTTP 200) and regression guard (basic smoke tests)\nAcceptance criteria:\n- Deploys only considered successful when health checks pass\n- Production promotion requires passing staging checks and approval",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 30,
        "title": "Performance monitoring and observability",
        "description": "Implement comprehensive monitoring with error tracking, APM, and custom metrics dashboards",
        "details": "Enhance existing Sentry integration for comprehensive error monitoring, implement application performance monitoring using Vercel Analytics or DataDog, create custom metrics dashboards for course engagement and platform usage, implement log aggregation using existing logger, add uptime monitoring for critical endpoints, create alerting rules for performance degradation, implement user session recording (optional), and add database performance monitoring.",
        "testStrategy": "Monitoring accuracy verification, alert triggering tests, dashboard functionality validation, performance impact assessment of monitoring, and incident response procedure testing",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Enhance Sentry error monitoring",
            "description": "Upgrade Sentry integration for comprehensive error tracking across frontend and backend.",
            "dependencies": [],
            "details": "Audit current Sentry setup; enable release tracking with commit SHAs and auto source map upload in CI; add environment, user, and request context with breadcrumbs and tags; implement PII scrubbing and ignore/deny lists; configure alert routing to Slack/Email with ownership rules and issue triage workflow; add health checks to verify error capture in staging and production; optional: enable Sentry Session Replay for privacy-safe user session recording.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement APM with database performance monitoring",
            "description": "Add application performance monitoring (APM) using DataDog (or Vercel Analytics alternative) including DB metrics.",
            "dependencies": [],
            "details": "Select APM provider (DataDog preferred); provision account, API keys, and environments; install and configure APM SDK (dd-trace) for backend/Next.js with service/env/version; instrument HTTP routes, background jobs, external calls, and propagate trace context via headers; enable DB integrations (e.g., Postgres/Prisma) with query latency, throughput, and slow query thresholds; collect runtime metrics (CPU, memory, event loop) and RED/USE metrics; validate traces and DB performance views; document instrumentation and rollout plan.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement centralized log aggregation",
            "description": "Aggregate structured logs using existing logger with correlation to APM traces.",
            "dependencies": [
              "30.2"
            ],
            "details": "Standardize JSON log format with levels, requestId, and trace/span IDs for correlation; configure transport to log backend (DataDog Logs/ELK/Logtail) via agentless HTTP; implement field redaction for sensitive data and set retention policies; create saved queries and views for key services and error classes; add sampling/backpressure to control cost; verify end-to-end correlation from trace to logs and perform volume tests.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add uptime monitoring and alerting rules",
            "description": "Set up synthetic uptime checks and alerting for critical endpoints and performance degradation.",
            "dependencies": [
              "30.1",
              "30.2"
            ],
            "details": "Identify critical endpoints (health, auth, payments, webhooks); configure synthetic monitors from multiple regions with TLS/domain expiry checks; define alert thresholds for availability, latency, error rate, and saturation; route notifications to Slack/PagerDuty with on-call schedules, escalation policies, and maintenance windows; implement runbooks; run failover/chaos drills to verify alert triggers and incident workflows.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create custom metrics and dashboards for engagement and usage",
            "description": "Define KPIs and build dashboards for course engagement and platform usage with alerts.",
            "dependencies": [
              "30.2",
              "30.3"
            ],
            "details": "Define KPIs (DAU/MAU, retention, conversion, enrollments, watch time, completion rates, quiz pass rates, active sessions); instrument event tracking on frontend and backend to emit custom metrics (DataDog metrics or compatible provider); model metrics with dimensions (course, cohort, device, geo) and annotate releases; build dashboards for product, engineering, and ops; set SLOs/SLIs and alerts for significant drops or spikes; validate metrics against database reports and document ownership.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-05T05:04:59.766Z",
      "taskCount": 30,
      "completedCount": 14,
      "tags": [
        "master"
      ],
      "created": "2025-10-05T05:10:02.779Z",
      "description": "Tasks for master context",
      "updated": "2025-10-05T06:06:39.501Z"
    }
  }
}